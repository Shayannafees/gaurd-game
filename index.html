<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChessFighter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: white;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            border: 2px solid #FFD700;
            transition: border-color 0.3s;
        }
        #ui.check-warning {
            border-color: #FF0000;
            animation: pulse 0.5s infinite;
        }
        @keyframes pulse {
            0% { border-width: 2px; }
            50% { border-width: 4px; }
            100% { border-width: 2px; }
        }
        #checkAlert {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #FF0000;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            display: none;
            z-index: 20;
            animation: checkFlash 1s ease-out;
        }
        @keyframes checkFlash {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
        #fightUI {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: none;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            border: 3px solid #FF0000;
            width: 700px;
        }
        .healthBar {
            width: 250px;
            height: 30px;
            background: #333;
            border: 2px solid #fff;
            position: relative;
            margin: 5px 0;
        }
        .healthFill {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ffff00);
            transition: width 0.3s;
        }
        .controls {
            margin-top: 10px;
            font-size: 12px;
            color: #FFD700;
        }
        #turnIndicator {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .fightContainer {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .fighterInfo {
            text-align: center;
        }
        #fightTimer {
            font-size: 24px;
            color: #FFD700;
            text-align: center;
            margin: 10px 0;
        }
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #startScreen h1 {
            font-size: 72px;
            margin: 0;
            background: linear-gradient(45deg, #FFD700, #FF0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #startScreen button {
            font-size: 24px;
            padding: 15px 40px;
            margin: 10px;
            background: #FFD700;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.3s;
        }
        #startScreen button:hover {
            background: #FF0000;
            color: #FFF;
            transform: scale(1.1);
        }
        .difficulty-buttons {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .difficulty-buttons button {
            font-size: 18px;
            padding: 10px 30px;
        }
        #victoryScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #victoryScreen h2 {
            font-size: 64px;
            margin: 20px;
            color: #FFD700;
        }
        #victoryScreen button {
            font-size: 24px;
            padding: 15px 40px;
            margin: 10px;
            background: #FFD700;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .status-effect {
            font-size: 14px;
            margin-top: 5px;
        }
        .frozen { color: #00FFFF; }
        .boosted { color: #FF00FF; }
        .shielded { color: #00FF00; }
        .speedy { color: #FFFF00; }
        #capturedPieces {
            margin-top: 20px;
            font-size: 14px;
        }
        .captured-section {
            margin: 5px 0;
        }
        #specialAbilities {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 5px;
            border: 1px solid #FFD700;
        }
        .ability-section {
            margin: 5px 0;
            font-size: 13px;
        }
        .ability-title {
            color: #FFD700;
            font-weight: bold;
        }
        .ability-desc {
            color: #CCCCCC;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="startScreen">
            <h1>CHESSFIGHTER</h1>
            <p style="font-size: 20px; color: #FFD700;">Chess meets Street Fighter!</p>
            <button onclick="startTwoPlayer()">TWO PLAYER</button>
            <div class="difficulty-buttons">
                <button onclick="startAI('easy')">AI - EASY</button>
                <button onclick="startAI('medium')">AI - MEDIUM</button>
                <button onclick="startAI('hard')">AI - HARD</button>
            </div>
            <div class="controls" style="margin-top: 30px;">
                <p><strong>Chess:</strong> Click pieces to move</p>
                <p><strong>Fighting:</strong> A/D - Move, W - Jump, S - Crouch</p>
                <p>J - Punch (10 HP), K - Kick (20 HP), L - Block (75% reduction)</p>
                <p>Space - Special Move (5s cooldown)</p>
            </div>
        </div>
        <div id="ui">
            <div id="turnIndicator">White's Turn</div>
            <div id="gameMode">Two Player</div>
            <div>Click a piece to see moves</div>
            <div>Capture triggers battle!</div>
            <div id="capturedPieces">
                <div class="captured-section">White captured: <span id="whiteCaptured"></span></div>
                <div class="captured-section">Black captured: <span id="blackCaptured"></span></div>
            </div>
        </div>
        <div id="checkAlert">CHECK!</div>
        <div id="fightUI">
            <div id="fightTimer">30</div>
            <div class="fightContainer">
                <div class="fighterInfo">
                    <div id="attackerName">Attacker</div>
                    <div class="healthBar">
                        <div id="attackerHealth" class="healthFill" style="width: 100%"></div>
                    </div>
                    <div>HP: <span id="attackerHP">50</span>/<span id="attackerMaxHP">50</span></div>
                    <div id="attackerSpecial" style="color: #00FF00;">Special Ready!</div>
                    <div id="attackerStatus" class="status-effect"></div>
                </div>
                <div style="font-size: 36px; color: #FF0000;">VS</div>
                <div class="fighterInfo">
                    <div id="defenderName">Defender</div>
                    <div class="healthBar">
                        <div id="defenderHealth" class="healthFill" style="width: 100%"></div>
                    </div>
                    <div>HP: <span id="defenderHP">50</span>/<span id="defenderMaxHP">50</span></div>
                    <div id="defenderSpecial" style="color: #00FF00;">Special Ready!</div>
                    <div id="defenderStatus" class="status-effect"></div>
                </div>
            </div>
            <div class="controls">
                A/D: Move | W: Jump | S: Crouch | J: Punch | K: Kick | L: Block | Space: Special
            </div>
            <div id="specialAbilities">
                <div class="ability-section">
                    <span class="ability-title" id="attackerAbilityTitle">Attacker Special:</span>
                    <span class="ability-desc" id="attackerAbilityDesc">Special ability description</span>
                </div>
                <div class="ability-section">
                    <span class="ability-title" id="defenderAbilityTitle">Defender Special:</span>
                    <span class="ability-desc" id="defenderAbilityDesc">Special ability description</span>
                </div>
            </div>
        </div>
        <div id="victoryScreen">
            <h2 id="victoryMessage">Checkmate!</h2>
            <p id="winnerMessage" style="font-size: 24px; color: #FFD700;"></p>
            <button onclick="rematch()">REMATCH</button>
            <button onclick="backToMenu()">MAIN MENU</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let board = [];
        let pieces = [];
        let selectedPiece = null;
        let legalMoves = [];
        let currentTurn = 'white';
        let highlightMeshes = [];
        let raycaster, mouse;
        let fighting = false;
        let fightScene, fightCamera;
        let attacker, defender;
        let fightTimer;
        let keys = {};
        let gameMode = 'twoPlayer';
        let aiDifficulty = 'medium';
        let isInCheck = false;
        let checkingPieces = [];
        let capturedPieces = { white: [], black: [] };
        let gameOver = false;
        let moveHistory = [];
        let halfMoveClock = 0; // For 50-move rule
        let positionHistory = []; // For threefold repetition
        let cameraAnimating = false;

        const PIECE_TYPES = {
            PAWN: 'pawn',
            KNIGHT: 'knight',
            BISHOP: 'bishop',
            ROOK: 'rook',
            QUEEN: 'queen',
            KING: 'king'
        };

        const PIECE_VALUES = {
            pawn: 1,
            knight: 3,
            bishop: 3,
            rook: 5,
            queen: 9,
            king: 100
        };

        const PIECE_HEALTH = {
            pawn: 50,
            knight: 80,
            bishop: 80,
            rook: 100,
            queen: 150,
            king: 120
        };

        // Sound system
        let audioContext;
        
        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        function playSound(type) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'punch':
                    oscillator.frequency.value = 150;
                    gainNode.gain.value = 0.3;
                    oscillator.type = 'square';
                    break;
                case 'kick':
                    oscillator.frequency.value = 100;
                    gainNode.gain.value = 0.4;
                    oscillator.type = 'sawtooth';
                    break;
                case 'special':
                    oscillator.frequency.value = 400;
                    gainNode.gain.value = 0.5;
                    oscillator.type = 'sine';
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
                    break;
                case 'hit':
                    oscillator.frequency.value = 200;
                    gainNode.gain.value = 0.2;
                    oscillator.type = 'noise';
                    break;
                case 'block':
                    oscillator.frequency.value = 300;
                    gainNode.gain.value = 0.1;
                    oscillator.type = 'triangle';
                    break;
                case 'check':
                    oscillator.frequency.value = 800;
                    gainNode.gain.value = 0.6;
                    oscillator.type = 'sine';
                    oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.3);
                    break;
                case 'checkmate':
                    oscillator.frequency.value = 600;
                    gainNode.gain.value = 0.7;
                    oscillator.type = 'sine';
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            const osc = audioContext.createOscillator();
                            const gain = audioContext.createGain();
                            osc.connect(gain);
                            gain.connect(audioContext.destination);
                            osc.frequency.value = 600 + i * 200;
                            gain.gain.value = 0.5;
                            osc.start();
                            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                            osc.stop(audioContext.currentTime + 0.3);
                        }, i * 100);
                    }
                    break;
                case 'stalemate':
                    oscillator.frequency.value = 300;
                    gainNode.gain.value = 0.4;
                    oscillator.type = 'triangle';
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.5);
                    break;
            }
            
            oscillator.start();
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            oscillator.stop(audioContext.currentTime + 0.2);
        }

        class ChessPiece {
            constructor(type, color, x, y) {
                this.type = type;
                this.color = color;
                this.x = x;
                this.y = y;
                this.hasMoved = false;
                this.mesh = this.createMesh();
                this.maxHealth = PIECE_HEALTH[type];
                this.health = this.maxHealth;
                this.enPassantTarget = false;
            }

            createMesh() {
                const group = new THREE.Group();
                
                // Create larger click helper that's easier to click
                const clickGeometry = new THREE.BoxGeometry(0.95, 1.2, 0.95);
                const clickMaterial = new THREE.MeshBasicMaterial({ 
                    transparent: true,
                    opacity: 0.01, // Very transparent but not invisible
                    color: 0x00ff00 // Green tint for debugging (barely visible)
                });
                const clickHelper = new THREE.Mesh(clickGeometry, clickMaterial);
                clickHelper.position.y = 0.6;
                clickHelper.userData = { 
                    piece: this, 
                    isClickHelper: true 
                };
                // Make sure the click helper is rendered
                clickHelper.renderOrder = 1000;
                group.add(clickHelper);
                
                // Base cylinder - make it fill most of the square
                const geometry = new THREE.CylinderGeometry(0.48, 0.48, 0.6, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: this.color === 'white' ? 0xF5F5F5 : 0x565352
                });
                const cylinder = new THREE.Mesh(geometry, material);
                cylinder.position.y = 0.3;
                cylinder.castShadow = true;
                cylinder.receiveShadow = true;
                cylinder.userData = { piece: this };
                group.add(cylinder);
                
                // Top disc with piece symbol
                const discGeometry = new THREE.CircleGeometry(0.48, 32);
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // Draw background circle
                ctx.fillStyle = this.color === 'white' ? '#F5F5F5' : '#565352';
                ctx.beginPath();
                ctx.arc(128, 128, 120, 0, Math.PI * 2);
                ctx.fill();
                
                // Set colors for piece symbol
                const pieceColor = this.color === 'white' ? '#000000' : '#FFFFFF';
                const outlineColor = this.color === 'white' ? '#FFFFFF' : '#000000';
                
                ctx.strokeStyle = outlineColor;
                ctx.fillStyle = pieceColor;
                ctx.lineWidth = 4;
                
                // Draw piece symbol
                ctx.save();
                ctx.translate(128, 128);
                if (this.color === 'white') {
                    ctx.rotate(Math.PI); // Rotate 180 degrees for white pieces
                }
                ctx.scale(2, 2); // Make pieces bigger
                
                switch(this.type) {
                    case PIECE_TYPES.PAWN:
                        // Pawn shape
                        ctx.beginPath();
                        ctx.arc(0, -15, 12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(-15, 20);
                        ctx.lineTo(-8, 5);
                        ctx.lineTo(-8, -5);
                        ctx.lineTo(8, -5);
                        ctx.lineTo(8, 5);
                        ctx.lineTo(15, 20);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                        
                    case PIECE_TYPES.KNIGHT:
                        // Knight shape
                        ctx.beginPath();
                        ctx.moveTo(-20, 20);
                        ctx.lineTo(-15, 5);
                        ctx.lineTo(-10, -5);
                        ctx.bezierCurveTo(-10, -15, -5, -20, 5, -20);
                        ctx.lineTo(10, -15);
                        ctx.lineTo(15, -8);
                        ctx.lineTo(12, 0);
                        ctx.lineTo(8, 5);
                        ctx.lineTo(20, 20);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Add eye
                        ctx.fillStyle = outlineColor;
                        ctx.beginPath();
                        ctx.arc(5, -10, 3, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case PIECE_TYPES.BISHOP:
                        // Bishop shape
                        ctx.beginPath();
                        ctx.arc(0, -15, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(-15, 20);
                        ctx.lineTo(-8, 5);
                        ctx.lineTo(-5, -5);
                        ctx.lineTo(5, -5);
                        ctx.lineTo(8, 5);
                        ctx.lineTo(15, 20);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Add cross
                        ctx.strokeStyle = outlineColor;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(0, -25);
                        ctx.lineTo(0, -10);
                        ctx.stroke();
                        break;
                        
                    case PIECE_TYPES.ROOK:
                        // Rook shape
                        ctx.beginPath();
                        ctx.moveTo(-20, 20);
                        ctx.lineTo(-15, -5);
                        ctx.lineTo(-15, -15);
                        ctx.lineTo(-10, -15);
                        ctx.lineTo(-10, -10);
                        ctx.lineTo(-5, -10);
                        ctx.lineTo(-5, -15);
                        ctx.lineTo(5, -15);
                        ctx.lineTo(5, -10);
                        ctx.lineTo(10, -10);
                        ctx.lineTo(10, -15);
                        ctx.lineTo(15, -15);
                        ctx.lineTo(15, -5);
                        ctx.lineTo(20, 20);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                        
                    case PIECE_TYPES.QUEEN:
                        // Queen shape
                        ctx.fillStyle = pieceColor;
                        ctx.beginPath();
                        ctx.moveTo(-20, 20);
                        ctx.lineTo(-12, 0);
                        ctx.lineTo(-15, -15);
                        ctx.lineTo(-10, -10);
                        ctx.lineTo(-5, -20);
                        ctx.lineTo(0, -15);
                        ctx.lineTo(5, -20);
                        ctx.lineTo(10, -10);
                        ctx.lineTo(15, -15);
                        ctx.lineTo(12, 0);
                        ctx.lineTo(20, 20);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Add crown jewels
                        ctx.fillStyle = outlineColor;
                        ctx.beginPath();
                        ctx.arc(-10, -15, 2, 0, Math.PI * 2);
                        ctx.arc(0, -20, 2, 0, Math.PI * 2);
                        ctx.arc(10, -15, 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case PIECE_TYPES.KING:
                        // King shape
                        ctx.fillStyle = pieceColor;
                        ctx.beginPath();
                        ctx.moveTo(-18, 20);
                        ctx.lineTo(-12, 0);
                        ctx.lineTo(-12, -10);
                        ctx.lineTo(12, -10);
                        ctx.lineTo(12, 0);
                        ctx.lineTo(18, 20);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        // Add cross
                        ctx.fillStyle = pieceColor;
                        ctx.fillRect(-2, -25, 4, 15);
                        ctx.fillRect(-8, -20, 16, 4);
                        ctx.strokeStyle = outlineColor;
                        ctx.strokeRect(-2, -25, 4, 15);
                        ctx.strokeRect(-8, -20, 16, 4);
                        break;
                }
                
                ctx.restore();
                
                // Apply texture to disc
                const texture = new THREE.CanvasTexture(canvas);
                const discMaterial = new THREE.MeshBasicMaterial({ 
                    map: texture,
                    side: THREE.DoubleSide
                });
                const disc = new THREE.Mesh(discGeometry, discMaterial);
                disc.rotation.x = -Math.PI / 2;
                disc.position.y = 0.61;
                disc.userData = { piece: this };
                group.add(disc);
                
                // Add reference to piece on group
                group.userData = { piece: this };
                
                group.position.set(this.x - 3.5, 0, this.y - 3.5);
                
                return group;
            }

            getLegalMoves() {
                const moves = [];
                const potentialMoves = this.getPotentialMoves();
                
                // Filter out moves that would leave king in check
                potentialMoves.forEach(move => {
                    if (!this.wouldLeaveKingInCheck(move.x, move.y)) {
                        moves.push(move);
                    }
                });
                
                return moves;
            }

            getPotentialMoves() {
                const moves = [];
                
                switch(this.type) {
                    case PIECE_TYPES.PAWN:
                        const direction = this.color === 'white' ? 1 : -1;
                        // Forward move
                        if (this.isValidMove(this.x, this.y + direction) && !pieces.some(p => p.x === this.x && p.y === this.y + direction)) {
                            moves.push({x: this.x, y: this.y + direction});
                            // Double move on first turn
                            if (!this.hasMoved && !pieces.some(p => p.x === this.x && p.y === this.y + 2 * direction)) {
                                moves.push({x: this.x, y: this.y + 2 * direction});
                            }
                        }
                        // Captures
                        [-1, 1].forEach(dx => {
                            const piece = pieces.find(p => p.x === this.x + dx && p.y === this.y + direction);
                            if (piece && piece.color !== this.color) {
                                moves.push({x: this.x + dx, y: this.y + direction});
                            }
                        });
                        // En passant
                        [-1, 1].forEach(dx => {
                            const piece = pieces.find(p => p.x === this.x + dx && p.y === this.y);
                            if (piece && piece.type === PIECE_TYPES.PAWN && piece.color !== this.color && piece.enPassantTarget) {
                                moves.push({x: this.x + dx, y: this.y + direction, enPassant: true});
                            }
                        });
                        break;
                        
                    case PIECE_TYPES.KNIGHT:
                        const knightMoves = [
                            [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                            [1, -2], [1, 2], [2, -1], [2, 1]
                        ];
                        knightMoves.forEach(([dx, dy]) => {
                            if (this.canMoveTo(this.x + dx, this.y + dy)) {
                                moves.push({x: this.x + dx, y: this.y + dy});
                            }
                        });
                        break;
                        
                    case PIECE_TYPES.BISHOP:
                        [[1,1], [1,-1], [-1,1], [-1,-1]].forEach(([dx, dy]) => {
                            for (let i = 1; i < 8; i++) {
                                const x = this.x + dx * i;
                                const y = this.y + dy * i;
                                if (!this.isValidMove(x, y)) break;
                                const piece = pieces.find(p => p.x === x && p.y === y);
                                if (piece) {
                                    if (piece.color !== this.color) moves.push({x, y});
                                    break;
                                }
                                moves.push({x, y});
                            }
                        });
                        break;
                        
                    case PIECE_TYPES.ROOK:
                        [[0,1], [0,-1], [1,0], [-1,0]].forEach(([dx, dy]) => {
                            for (let i = 1; i < 8; i++) {
                                const x = this.x + dx * i;
                                const y = this.y + dy * i;
                                if (!this.isValidMove(x, y)) break;
                                const piece = pieces.find(p => p.x === x && p.y === y);
                                if (piece) {
                                    if (piece.color !== this.color) moves.push({x, y});
                                    break;
                                }
                                moves.push({x, y});
                            }
                        });
                        break;
                        
                    case PIECE_TYPES.QUEEN:
                        [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]].forEach(([dx, dy]) => {
                            for (let i = 1; i < 8; i++) {
                                const x = this.x + dx * i;
                                const y = this.y + dy * i;
                                if (!this.isValidMove(x, y)) break;
                                const piece = pieces.find(p => p.x === x && p.y === y);
                                if (piece) {
                                    if (piece.color !== this.color) moves.push({x, y});
                                    break;
                                }
                                moves.push({x, y});
                            }
                        });
                        break;
                        
                    case PIECE_TYPES.KING:
                        [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]].forEach(([dx, dy]) => {
                            if (this.canMoveTo(this.x + dx, this.y + dy)) {
                                moves.push({x: this.x + dx, y: this.y + dy});
                            }
                        });
                        // Castling
                        if (!this.hasMoved && !isInCheck) {
                            // Kingside
                            const kRook = pieces.find(p => p.x === 7 && p.y === this.y && p.type === PIECE_TYPES.ROOK && p.color === this.color);
                            if (kRook && !kRook.hasMoved) {
                                if (!pieces.some(p => (p.x === 5 || p.x === 6) && p.y === this.y)) {
                                    if (!this.wouldBeInCheck(5, this.y) && !this.wouldBeInCheck(6, this.y)) {
                                        moves.push({x: 6, y: this.y, castle: 'kingside'});
                                    }
                                }
                            }
                            // Queenside
                            const qRook = pieces.find(p => p.x === 0 && p.y === this.y && p.type === PIECE_TYPES.ROOK && p.color === this.color);
                            if (qRook && !qRook.hasMoved) {
                                if (!pieces.some(p => (p.x === 1 || p.x === 2 || p.x === 3) && p.y === this.y)) {
                                    if (!this.wouldBeInCheck(2, this.y) && !this.wouldBeInCheck(3, this.y)) {
                                        moves.push({x: 2, y: this.y, castle: 'queenside'});
                                    }
                                }
                            }
                        }
                        break;
                }
                
                return moves;
            }

            wouldLeaveKingInCheck(targetX, targetY) {
                // Simulate the move
                const originalX = this.x;
                const originalY = this.y;
                const capturedPiece = pieces.find(p => p.x === targetX && p.y === targetY);
                const capturedIndex = capturedPiece ? pieces.indexOf(capturedPiece) : -1;
                
                this.x = targetX;
                this.y = targetY;
                if (capturedPiece) {
                    pieces.splice(capturedIndex, 1);
                }
                
                // Check if king is in check
                const king = pieces.find(p => p.type === PIECE_TYPES.KING && p.color === this.color);
                const inCheck = king ? isKingInCheck(king) : false;
                
                // Restore original state
                this.x = originalX;
                this.y = originalY;
                if (capturedPiece) {
                    pieces.splice(capturedIndex, 0, capturedPiece);
                }
                
                return inCheck;
            }

            wouldBeInCheck(x, y) {
                // Check if this position would be under attack
                return pieces.some(p => {
                    if (p.color === this.color) return false;
                    const moves = p.getPotentialMoves();
                    return moves.some(m => m.x === x && m.y === y);
                });
            }

            isValidMove(x, y) {
                return x >= 0 && x < 8 && y >= 0 && y < 8;
            }

            canMoveTo(x, y) {
                if (!this.isValidMove(x, y)) return false;
                const piece = pieces.find(p => p.x === x && p.y === y);
                return !piece || piece.color !== this.color;
            }
        }

        class Fighter {
            constructor(piece, isAttacker) {
                this.piece = piece;
                this.isAttacker = isAttacker;
                this.x = isAttacker ? -2 : 2;
                this.y = 0;
                this.vx = 0;
                this.vy = 0;
                this.health = piece.health;
                this.maxHealth = piece.maxHealth;
                this.specialCooldown = 0;
                this.blocking = false;
                this.mesh = this.createFighterMesh();
                this.animationTime = 0;
                this.currentAnimation = null;
                this.effects = [];
                
                // Status effects
                this.frozen = 0;
                this.damageBoost = 0;
                this.damageReduction = 0;
                this.speedBoost = 0;
            }

            createFighterMesh() {
                const group = new THREE.Group();
                const color = this.piece.color === 'white' ? 0xFFFFFF : 0x1A1A1A;
                const emissiveColor = this.piece.color === 'white' ? 0xFFD700 : 0x9400D3;
                
                // Create piece-specific meshes with better contrast
                switch(this.piece.type) {
                    case PIECE_TYPES.PAWN:
                        // Pawn body
                        const pawnBody = new THREE.ConeGeometry(0.3, 0.8, 8);
                        const pawnMat = new THREE.MeshPhongMaterial({ 
                            color, 
                            emissive: emissiveColor,
                            emissiveIntensity: 0.3,
                            specular: 0x111111,
                            shininess: 100
                        });
                        const pawnMesh = new THREE.Mesh(pawnBody, pawnMat);
                        pawnMesh.position.y = 0.4;
                        group.add(pawnMesh);
                        
                        // Pawn head
                        const pawnHead = new THREE.SphereGeometry(0.2, 8, 8);
                        const headMesh = new THREE.Mesh(pawnHead, pawnMat);
                        headMesh.position.y = 0.9;
                        group.add(headMesh);
                        break;
                        
                    case PIECE_TYPES.KNIGHT:
                        // Knight body
                        const knightBody = new THREE.BoxGeometry(0.4, 0.6, 0.3);
                        const knightMat = new THREE.MeshPhongMaterial({ 
                            color,
                            emissive: emissiveColor,
                            emissiveIntensity: 0.3,
                            specular: 0x111111,
                            shininess: 100
                        });
                        const knightBase = new THREE.Mesh(knightBody, knightMat);
                        knightBase.position.y = 0.3;
                        group.add(knightBase);
                        
                        // Horse head shape
                        const horseHead = new THREE.ConeGeometry(0.25, 0.6, 4);
                        const horseMesh = new THREE.Mesh(horseHead, knightMat);
                        horseMesh.position.y = 0.8;
                        horseMesh.rotation.z = Math.PI / 4;
                        group.add(horseMesh);
                        break;
                        
                    case PIECE_TYPES.BISHOP:
                        // Bishop body
                        const bishopBody = new THREE.CylinderGeometry(0.2, 0.35, 0.8, 8);
                        const bishopMat = new THREE.MeshPhongMaterial({ 
                            color,
                            emissive: emissiveColor,
                            emissiveIntensity: 0.4,
                            specular: 0x111111,
                            shininess: 100
                        });
                        const bishopMesh = new THREE.Mesh(bishopBody, bishopMat);
                        bishopMesh.position.y = 0.4;
                        group.add(bishopMesh);
                        
                        // Bishop hat
                        const bishopHat = new THREE.ConeGeometry(0.2, 0.4, 4);
                        const hatMesh = new THREE.Mesh(bishopHat, bishopMat);
                        hatMesh.position.y = 1;
                        group.add(hatMesh);
                        break;
                        
                    case PIECE_TYPES.ROOK:
                        // Rook tower
                        const rookBody = new THREE.BoxGeometry(0.6, 1, 0.6);
                        const rookMat = new THREE.MeshPhongMaterial({ 
                            color,
                            emissive: emissiveColor,
                            emissiveIntensity: 0.3,
                            specular: 0x111111,
                            shininess: 100
                        });
                        const rookMesh = new THREE.Mesh(rookBody, rookMat);
                        rookMesh.position.y = 0.5;
                        group.add(rookMesh);
                        
                        // Battlements
                        for (let i = 0; i < 4; i++) {
                            const battlement = new THREE.BoxGeometry(0.15, 0.2, 0.15);
                            const batMesh = new THREE.Mesh(battlement, rookMat);
                            const angle = (i / 4) * Math.PI * 2;
                            batMesh.position.x = Math.cos(angle) * 0.2;
                            batMesh.position.z = Math.sin(angle) * 0.2;
                            batMesh.position.y = 1.1;
                            group.add(batMesh);
                        }
                        break;
                        
                    case PIECE_TYPES.QUEEN:
                        // Queen body
                        const queenBody = new THREE.CylinderGeometry(0.25, 0.4, 0.8, 8);
                        const queenMat = new THREE.MeshPhongMaterial({ 
                            color,
                            emissive: emissiveColor,
                            emissiveIntensity: 0.5,
                            specular: 0x111111,
                            shininess: 100
                        });
                        const queenMesh = new THREE.Mesh(queenBody, queenMat);
                        queenMesh.position.y = 0.4;
                        group.add(queenMesh);
                        
                        // Crown
                        const crownBase = new THREE.TorusGeometry(0.25, 0.05, 8, 8);
                        const crownMesh = new THREE.Mesh(crownBase, queenMat);
                        crownMesh.position.y = 0.9;
                        crownMesh.rotation.x = Math.PI / 2;
                        group.add(crownMesh);
                        
                        // Crown points
                        for (let i = 0; i < 8; i++) {
                            const point = new THREE.ConeGeometry(0.05, 0.2, 4);
                            const pointMesh = new THREE.Mesh(point, queenMat);
                            const angle = (i / 8) * Math.PI * 2;
                            pointMesh.position.x = Math.cos(angle) * 0.2;
                            pointMesh.position.z = Math.sin(angle) * 0.2;
                            pointMesh.position.y = 1.1;
                            group.add(pointMesh);
                        }
                        break;
                        
                    case PIECE_TYPES.KING:
                        // King body
                        const kingBody = new THREE.BoxGeometry(0.5, 0.8, 0.5);
                        const kingMat = new THREE.MeshPhongMaterial({ 
                            color,
                            emissive: emissiveColor,
                            emissiveIntensity: 0.4,
                            specular: 0x111111,
                            shininess: 100
                        });
                        const kingMesh = new THREE.Mesh(kingBody, kingMat);
                        kingMesh.position.y = 0.4;
                        group.add(kingMesh);
                        
                        // Cross on top
                        const crossV = new THREE.BoxGeometry(0.1, 0.4, 0.1);
                        const crossH = new THREE.BoxGeometry(0.3, 0.1, 0.1);
                        const crossVMesh = new THREE.Mesh(crossV, kingMat);
                        const crossHMesh = new THREE.Mesh(crossH, kingMat);
                        crossVMesh.position.y = 1;
                        crossHMesh.position.y = 1.1;
                        group.add(crossVMesh);
                        group.add(crossHMesh);
                        break;
                }
                
                // Add outline effect for better visibility
                group.children.forEach(child => {
                    if (child.material) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                group.position.set(this.x, this.y, 0);
                return group;
            }

            update(deltaTime) {
                // Check if frozen
                if (this.frozen > 0) {
                    this.frozen -= deltaTime;
                    this.vx = 0;
                    this.updateStatusDisplay();
                    return;
                }
                
                // Update status effect timers
                if (this.damageBoost > 0) this.damageBoost -= deltaTime;
                if (this.damageReduction > 0) this.damageReduction -= deltaTime;
                if (this.speedBoost > 0) this.speedBoost -= deltaTime;
                
                // Slower gravity
                this.vy -= 0.008;
                
                // Update position with speed boost
                const speedMultiplier = this.speedBoost > 0 ? 1.3 : 1; // Reduced from 1.5 to 1.3
                this.x += this.vx * speedMultiplier;
                this.y += this.vy;
                
                // Ground collision
                if (this.y <= 0) {
                    this.y = 0;
                    this.vy = 0;
                }
                
                // Arena bounds (ring size)
                this.x = Math.max(-3, Math.min(3, this.x));
                
                // Update mesh
                this.mesh.position.set(this.x, this.y, 0);
                
                // Slower animations
                if (this.currentAnimation) {
                    this.animationTime += deltaTime * 0.7;
                    
                    switch(this.currentAnimation) {
                        case 'punch':
                            this.mesh.rotation.z = Math.sin(this.animationTime * 20) * 0.3;
                            if (this.animationTime > 0.4) {
                                this.mesh.rotation.z = 0;
                                this.currentAnimation = null;
                            }
                            break;
                        case 'kick':
                            this.mesh.rotation.x = Math.sin(this.animationTime * 15) * 0.6;
                            if (this.animationTime > 0.5) {
                                this.mesh.rotation.x = 0;
                                this.currentAnimation = null;
                            }
                            break;
                        case 'special':
                            this.mesh.rotation.y = this.animationTime * 8;
                            this.mesh.scale.setScalar(1 + Math.sin(this.animationTime * 15) * 0.15);
                            if (this.animationTime > 1.2) {
                                this.mesh.rotation.y = 0;
                                this.mesh.scale.setScalar(1);
                                this.currentAnimation = null;
                            }
                            break;
                        case 'hit':
                            this.mesh.position.x = this.x + Math.sin(this.animationTime * 40) * 0.08;
                            if (this.animationTime > 0.4) {
                                this.currentAnimation = null;
                            }
                            break;
                    }
                }
                
                // Update effects
                this.effects = this.effects.filter(effect => {
                    effect.life -= deltaTime;
                    effect.mesh.position.y += effect.vy * deltaTime * 0.7;
                    effect.mesh.material.opacity = effect.life / effect.maxLife;
                    if (effect.life <= 0) {
                        fightScene.remove(effect.mesh);
                        return false;
                    }
                    return true;
                });
                
                // Cooldowns
                if (this.specialCooldown > 0) {
                    this.specialCooldown -= deltaTime;
                }
                
                // Visual effects for status
                this.updateVisualEffects();
                this.updateStatusDisplay();
            }

            updateVisualEffects() {
                // Visual effects should only affect this fighter
                if (this.blocking) {
                    this.mesh.children.forEach(child => {
                        if (child.material) {
                            child.material.emissiveIntensity = 0.8;
                            child.material.emissive = new THREE.Color(0x0088FF);
                        }
                    });
                } else if (this.frozen > 0) {
                    this.mesh.children.forEach(child => {
                        if (child.material) {
                            child.material.emissiveIntensity = 0.6;
                            child.material.emissive = new THREE.Color(0x00FFFF);
                        }
                    });
                } else if (this.damageReduction > 0) {
                    this.mesh.children.forEach(child => {
                        if (child.material) {
                            child.material.emissiveIntensity = 0.5;
                            child.material.emissive = new THREE.Color(0x00FF00);
                        }
                    });
                } else if (this.speedBoost > 0) {
                    // Speed boost visual effect - only for this fighter
                    this.mesh.children.forEach(child => {
                        if (child.material) {
                            child.material.emissiveIntensity = 0.6;
                            child.material.emissive = new THREE.Color(0xFFFF00);
                        }
                    });
                } else if (this.damageBoost > 0) {
                    this.mesh.children.forEach(child => {
                        if (child.material) {
                            child.material.emissiveIntensity = 0.5;
                            child.material.emissive = new THREE.Color(0xFF00FF);
                        }
                    });
                } else {
                    // Default appearance
                    this.mesh.children.forEach(child => {
                        if (child.material) {
                            child.material.emissiveIntensity = 0.3;
                            child.material.emissive = new THREE.Color(
                                this.piece.color === 'white' ? 0xFFD700 : 0x9400D3
                            );
                        }
                    });
                }
            }

            updateStatusDisplay() {
                const statusEl = document.getElementById(this.isAttacker ? 'attackerStatus' : 'defenderStatus');
                const statuses = [];
                
                if (this.frozen > 0) statuses.push(`<span class="frozen">Frozen (${Math.ceil(this.frozen)}s)</span>`);
                if (this.damageBoost > 0) statuses.push(`<span class="boosted">Damage+ (${Math.ceil(this.damageBoost)}s)</span>`);
                if (this.damageReduction > 0) statuses.push(`<span class="shielded">Shield (${Math.ceil(this.damageReduction)}s)</span>`);
                if (this.speedBoost > 0) statuses.push(`<span class="speedy">Speed+ (${Math.ceil(this.speedBoost)}s)</span>`);
                
                statusEl.innerHTML = statuses.join(' ');
            }

            jump() {
                if (this.y === 0 && this.frozen <= 0) {
                    this.vy = 0.25;
                }
            }

            moveLeft() {
                if (this.frozen <= 0) {
                    this.vx = -0.025; // Reduced from 0.05 to 0.025
                }
            }

            moveRight() {
                if (this.frozen <= 0) {
                    this.vx = 0.025; // Reduced from 0.05 to 0.025
                }
            }

            stop() {
                this.vx *= 0.9; // Gradual stop
            }

            attack(type, target) {
                if (this.blocking || this.frozen > 0) return;
                
                const distance = Math.abs(this.x - target.x);
                let damage = 0;
                
                if (type === 'punch' && distance < 1) {
                    damage = 10;
                    if (this.damageBoost > 0) damage *= 1.25;
                    this.startAnimation('punch');
                    playSound('punch');
                    this.createHitEffect(target.x, target.y + 0.5, 0xFFFF00);
                } else if (type === 'kick' && distance < 1.5) {
                    damage = 20;
                    if (this.damageBoost > 0) damage *= 1.25;
                    this.startAnimation('kick');
                    playSound('kick');
                    this.createHitEffect(target.x, target.y + 0.7, 0xFF8800);
                } else if (type === 'special' && this.specialCooldown <= 0) {
                    this.performSpecialMove(target);
                    this.specialCooldown = 5;
                }
                
                if (damage > 0) {
                    if (!target.blocking) {
                        if (target.damageReduction > 0) damage *= 0.5;
                        target.takeDamage(damage);
                        target.startAnimation('hit');
                        playSound('hit');
                    } else {
                        target.takeDamage(damage * 0.25);
                        playSound('block');
                        this.createBlockEffect(target.x, target.y + 0.5);
                    }
                }
            }

            performSpecialMove(target) {
                this.startAnimation('special');
                playSound('special');
                
                switch(this.piece.type) {
                    case PIECE_TYPES.PAWN:
                        // Soldier's Resolve - Heal 20 HP
                        this.heal(20);
                        this.createHealEffect();
                        break;
                        
                    case PIECE_TYPES.KNIGHT:
                        // Gallant Charge - Speed boost for this fighter only
                        this.speedBoost = 2.5; // Reduced duration from 3 to 2.5 seconds
                        this.createSpeedEffect();
                        break;
                        
                    case PIECE_TYPES.BISHOP:
                        // Holy Ward - Damage reduction
                        this.damageReduction = 5;
                        this.createShieldEffect();
                        break;
                        
                    case PIECE_TYPES.ROOK:
                        // Fortress Stance - Heavy damage reduction
                        this.damageReduction = 4;
                        this.blocking = true;
                        setTimeout(() => { this.blocking = false; }, 4000);
                        this.createFortressEffect();
                        break;
                        
                    case PIECE_TYPES.QUEEN:
                        // Royal Command - Freeze opponent
                        target.frozen = 2;
                        this.createFreezeEffect(target);
                        break;
                        
                    case PIECE_TYPES.KING:
                        // Monarch's Rally - Heal and damage boost
                        this.heal(30);
                        this.damageBoost = 5;
                        this.createRallyEffect();
                        break;
                }
                
                this.createSpecialEffect(target);
            }

            heal(amount) {
                this.health = Math.min(this.maxHealth, this.health + amount);
                this.piece.health = this.health;
                this.updateHealthDisplay();
            }

            startAnimation(type) {
                this.currentAnimation = type;
                this.animationTime = 0;
            }
            
            createHitEffect(x, y, color) {
                const geometry = new THREE.SphereGeometry(0.2, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, 0);
                fightScene.add(mesh);
                
                this.effects.push({
                    mesh: mesh,
                    life: 0.5,
                    maxLife: 0.5,
                    vy: 2
                });
            }
            
            createBlockEffect(x, y) {
                for (let i = 0; i < 5; i++) {
                    const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0x0088FF,
                        transparent: true,
                        opacity: 1
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(
                        x + (Math.random() - 0.5) * 0.5,
                        y + (Math.random() - 0.5) * 0.5,
                        0
                    );
                    fightScene.add(mesh);
                    
                    this.effects.push({
                        mesh: mesh,
                        life: 0.3,
                        maxLife: 0.3,
                        vy: Math.random() * 2
                    });
                }
            }

            createHealEffect() {
                const geometry = new THREE.TorusGeometry(0.5, 0.1, 8, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00FF00,
                    transparent: true,
                    opacity: 1
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(this.x, this.y + 0.5, 0);
                mesh.rotation.x = Math.PI / 2;
                fightScene.add(mesh);
                
                // Animate heal ring
                const animateHeal = () => {
                    mesh.position.y += 0.02;
                    mesh.scale.multiplyScalar(1.02);
                    mesh.material.opacity *= 0.95;
                    if (mesh.material.opacity > 0.1) {
                        requestAnimationFrame(animateHeal);
                    } else {
                        fightScene.remove(mesh);
                    }
                };
                animateHeal();
            }

            createSpeedEffect() {
                // Create speed trail effect only for this fighter
                for (let i = 0; i < 10; i++) {
                    const geometry = new THREE.PlaneGeometry(0.2, 0.05);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xFFFF00,
                        transparent: true,
                        opacity: 1
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    // Position relative to this fighter only
                    mesh.position.set(this.x - i * 0.1, this.y + 0.5 + (Math.random() - 0.5) * 0.5, 0);
                    fightScene.add(mesh);
                    
                    this.effects.push({
                        mesh: mesh,
                        life: 0.5,
                        maxLife: 0.5,
                        vy: 0
                    });
                }
            }

            createShieldEffect() {
                const geometry = new THREE.SphereGeometry(0.8, 16, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00FF00,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(this.x, this.y + 0.5, 0);
                fightScene.add(mesh);
                
                // Animate shield
                const animateShield = () => {
                    mesh.scale.setScalar(1 + Math.sin(Date.now() * 0.01) * 0.1);
                    if (this.damageReduction > 0) {
                        requestAnimationFrame(animateShield);
                    } else {
                        fightScene.remove(mesh);
                    }
                };
                animateShield();
            }

            createFortressEffect() {
                const geometry = new THREE.BoxGeometry(1.2, 1.5, 0.1);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x666666,
                    transparent: true,
                    opacity: 0.7
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(this.x, this.y + 0.75, 0.5);
                fightScene.add(mesh);
                
                setTimeout(() => {
                    fightScene.remove(mesh);
                }, 4000);
            }

            createFreezeEffect(target) {
                const geometry = new THREE.BoxGeometry(0.8, 1.2, 0.8);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00FFFF,
                    transparent: true,
                    opacity: 0.5
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(target.x, target.y + 0.6, 0);
                fightScene.add(mesh);
                
                // Animate ice
                const animateIce = () => {
                    if (target.frozen > 0) {
                        mesh.rotation.y += 0.02;
                        requestAnimationFrame(animateIce);
                    } else {
                        fightScene.remove(mesh);
                    }
                };
                animateIce();
            }

            createRallyEffect() {
                // Crown glow
                const geometry = new THREE.TorusGeometry(0.4, 0.1, 8, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xFFD700,
                    transparent: true,
                    opacity: 1
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(this.x, this.y + 1.2, 0);
                mesh.rotation.x = Math.PI / 2;
                fightScene.add(mesh);
                
                // Animate crown
                const animateCrown = () => {
                    mesh.rotation.z += 0.05;
                    mesh.material.opacity *= 0.95;
                    if (mesh.material.opacity > 0.1) {
                        requestAnimationFrame(animateCrown);
                    } else {
                        fightScene.remove(mesh);
                    }
                };
                animateCrown();
            }
            
            createSpecialEffect(target) {
                const color = this.piece.color === 'white' ? 0xFFD700 : 0x9400D3;
                
                switch(this.piece.type) {
                    case PIECE_TYPES.PAWN:
                        // Already handled in performSpecialMove
                        break;
                        
                    case PIECE_TYPES.BISHOP:
                        // Already handled in performSpecialMove
                        break;
                        
                    case PIECE_TYPES.ROOK:
                        // Already handled in performSpecialMove
                        break;
                        
                    case PIECE_TYPES.QUEEN:
                        // Already handled in performSpecialMove
                        break;
                        
                    case PIECE_TYPES.KNIGHT:
                        // Already handled in performSpecialMove
                        break;
                        
                    case PIECE_TYPES.KING:
                        // Already handled in performSpecialMove
                        break;
                }
            }

            takeDamage(amount) {
                this.health = Math.max(0, this.health - amount);
                this.piece.health = this.health;
                this.startAnimation('hit');
                this.updateHealthDisplay();
            }

            updateHealthDisplay() {
                const hpEl = document.getElementById(this.isAttacker ? 'attackerHP' : 'defenderHP');
                hpEl.textContent = Math.ceil(this.health);
            }
        }

        function isKingInCheck(king) {
            if (!king) return false;
            
            return pieces.some(piece => {
                if (piece.color === king.color) return false;
                const moves = piece.getPotentialMoves();
                return moves.some(move => move.x === king.x && move.y === king.y);
            });
        }

        function checkForCheckmate(color) {
            const king = pieces.find(p => p.type === PIECE_TYPES.KING && p.color === color);
            if (!king) return false;
            
            // Must be in check
            if (!isKingInCheck(king)) return false;
            
            // Check if any piece can make a legal move
            const colorPieces = pieces.filter(p => p.color === color);
            for (const piece of colorPieces) {
                const legalMoves = piece.getLegalMoves();
                if (legalMoves.length > 0) return false;
            }
            
            return true;
        }

        function checkForStalemate(color) {
            const king = pieces.find(p => p.type === PIECE_TYPES.KING && p.color === color);
            if (!king) return false;
            
            // Must not be in check
            if (isKingInCheck(king)) return false;
            
            // Check if any piece can make a legal move
            const colorPieces = pieces.filter(p => p.color === color);
            for (const piece of colorPieces) {
                const legalMoves = piece.getLegalMoves();
                if (legalMoves.length > 0) return false;
            }
            
            return true;
        }

        function updateCheckStatus() {
            const king = pieces.find(p => p.type === PIECE_TYPES.KING && p.color === currentTurn);
            if (!king) return;
            
            const wasInCheck = isInCheck;
            isInCheck = isKingInCheck(king);
            
            if (isInCheck && !wasInCheck) {
                // Just entered check
                playSound('check');
                document.getElementById('checkAlert').style.display = 'block';
                document.getElementById('ui').classList.add('check-warning');
                
                // Find checking pieces
                checkingPieces = pieces.filter(piece => {
                    if (piece.color === currentTurn) return false;
                    const moves = piece.getPotentialMoves();
                    return moves.some(move => move.x === king.x && move.y === king.y);
                });
                
                // Flash king square
                flashKingSquare(king);
                
                setTimeout(() => {
                    document.getElementById('checkAlert').style.display = 'none';
                }, 1000);
            } else if (!isInCheck && wasInCheck) {
                // No longer in check
                document.getElementById('ui').classList.remove('check-warning');
            }
        }

        function flashKingSquare(king) {
            const squareIndex = king.y * 8 + king.x;
            const square = board[squareIndex];
            const originalColor = square.material.color.getHex();
            
            let flashes = 0;
            const flash = () => {
                if (flashes >= 6) {
                    square.material.color.setHex(originalColor);
                    return;
                }
                
                square.material.color.setHex(flashes % 2 === 0 ? 0xFF0000 : originalColor);
                flashes++;
                setTimeout(flash, 200);
            };
            flash();
        }

        function evaluateBoard() {
            let score = 0;
            
            if (pieces.length === 0) return 0;
            
            pieces.forEach(piece => {
                const value = PIECE_VALUES[piece.type] || 0;
                const positionBonus = getPositionBonus(piece);
                
                if (piece.color === 'white') {
                    score += value + positionBonus;
                } else {
                    score -= value + positionBonus;
                }
            });
            
            return score;
        }

        function minimax(depth, alpha, beta, maximizingPlayer) {
            // Simplified minimax for compatibility - not used in current AI
            if (depth === 0 || gameOver) {
                return evaluateBoard();
            }
            
            const targetColor = maximizingPlayer ? 'white' : 'black';
            const colorPieces = pieces.filter(p => p.color === targetColor);
            
            if (colorPieces.length === 0) {
                return maximizingPlayer ? -10000 : 10000;
            }
            
            // Just return board evaluation for now to avoid complexity
            return evaluateBoard() * (maximizingPlayer ? 1 : -1);
        }

        function getPositionBonus(piece) {
            // Simple position evaluation
            let bonus = 0;
            
            if (!piece) return 0;
            
            // Center control bonus
            const centerDistance = Math.abs(piece.x - 3.5) + Math.abs(piece.y - 3.5);
            bonus += (7 - centerDistance) * 0.1;
            
            // Specific piece bonuses
            switch(piece.type) {
                case PIECE_TYPES.PAWN:
                    // Advance bonus
                    bonus += (piece.color === 'white' ? piece.y : 7 - piece.y) * 0.1;
                    break;
                case PIECE_TYPES.KNIGHT:
                    // Center preference
                    if (piece.x >= 2 && piece.x <= 5 && piece.y >= 2 && piece.y <= 5) {
                        bonus += 0.3;
                    }
                    break;
                case PIECE_TYPES.KING:
                    // Safety bonus (castle position)
                    if (piece.y === (piece.color === 'white' ? 0 : 7)) {
                        if (piece.x === 2 || piece.x === 6) {
                            bonus += 0.5;
                        }
                    }
                    break;
            }
            
            return bonus;
        }

        function makeAIMove() {
            if (currentTurn !== 'black' || gameMode === 'twoPlayer' || gameOver) return;
            
            const depth = aiDifficulty === 'easy' ? 2 : aiDifficulty === 'medium' ? 4 : 6;
            let bestMove = null;
            let bestScore = -Infinity;
            
            const blackPieces = pieces.filter(p => p.color === 'black');
            
            // Evaluate all possible moves
            for (const piece of blackPieces) {
                const moves = piece.getLegalMoves();
                for (const move of moves) {
                    // Make move
                    const originalX = piece.x;
                    const originalY = piece.y;
                    const capturedPiece = pieces.find(p => p.x === move.x && p.y === move.y);
                    const capturedIndex = capturedPiece ? pieces.indexOf(capturedPiece) : -1;
                    
                    piece.x = move.x;
                    piece.y = move.y;
                    if (capturedPiece) {
                        pieces.splice(capturedIndex, 1);
                    }
                    
                    const score = -minimax(depth - 1, -Infinity, Infinity, true);
                    
                    // Undo move
                    piece.x = originalX;
                    piece.y = originalY;
                    if (capturedPiece) {
                        pieces.splice(capturedIndex, 0, capturedPiece);
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = { piece, move };
                    }
                }
            }
            
            // Make random mistakes on easy difficulty
            if (aiDifficulty === 'easy' && Math.random() < 0.3) {
                const randomPiece = blackPieces[Math.floor(Math.random() * blackPieces.length)];
                const moves = randomPiece.getLegalMoves();
                if (moves.length > 0) {
                    const randomMove = moves[Math.floor(Math.random() * moves.length)];
                    bestMove = { piece: randomPiece, move: randomMove };
                }
            }
            
            // Execute the best move
            if (bestMove) {
                setTimeout(() => {
                    selectedPiece = bestMove.piece;
                    movePiece(bestMove.piece, bestMove.move.x, bestMove.move.y);
                }, 1000);
            }
        }

        class FightingAI {
            constructor(fighter, opponent) {
                this.fighter = fighter;
                this.opponent = opponent;
                this.state = 'approach';
                this.stateTimer = 0;
                this.difficulty = gameMode === 'twoPlayer' ? 'medium' : aiDifficulty;
                
                // Set aggression based on piece type and difficulty
                this.aggression = this.getAggressionLevel();
                this.attackCooldown = 0;
                this.blockCounter = 0;
                this.reactionTime = 0; // Add reaction delay
                this.confusionTimer = 0; // Add confusion periods
            }

            getAggressionLevel() {
                let baseAggression;
                switch(this.fighter.piece.type) {
                    case PIECE_TYPES.PAWN:
                        baseAggression = 0.9;
                        break;
                    case PIECE_TYPES.KNIGHT:
                        baseAggression = 0.7;
                        break;
                    case PIECE_TYPES.BISHOP:
                        baseAggression = 0.5;
                        break;
                    case PIECE_TYPES.ROOK:
                        baseAggression = 0.4;
                        break;
                    case PIECE_TYPES.QUEEN:
                        baseAggression = 0.6;
                        break;
                    case PIECE_TYPES.KING:
                        baseAggression = 0.2;
                        break;
                    default:
                        baseAggression = 0.5;
                }
                
                // Reduce aggression significantly based on difficulty
                switch(this.difficulty) {
                    case 'easy':
                        return baseAggression * 0.3; // Much less aggressive
                    case 'medium':
                        return baseAggression * 0.6;
                    case 'hard':
                        return baseAggression;
                    default:
                        return baseAggression * 0.3;
                }
            }

            update(deltaTime) {
                if (this.fighter.frozen > 0) return;
                
                this.stateTimer += deltaTime;
                this.attackCooldown -= deltaTime;
                this.reactionTime -= deltaTime;
                this.confusionTimer -= deltaTime;
                
                const distance = Math.abs(this.fighter.x - this.opponent.x);
                const healthPercent = this.fighter.health / this.fighter.maxHealth;
                
                // Add confusion periods where AI does nothing
                if (this.confusionTimer > 0) {
                    this.fighter.stop();
                    return;
                }
                
                // Add reaction delay - AI doesn't react immediately
                if (this.reactionTime > 0) {
                    this.fighter.stop();
                    return;
                }
                
                // Adapt behavior based on health
                const effectiveAggression = healthPercent < 0.3 ? 
                    this.aggression * 0.5 : // More defensive when low health
                    this.aggression;
                
                // Much longer delays between actions based on difficulty
                const getActionDelay = () => {
                    switch(this.difficulty) {
                        case 'easy':
                            return 1.5 + Math.random() * 2; // 1.5-3.5 second delays
                        case 'medium':
                            return 0.8 + Math.random() * 1; // 0.8-1.8 second delays
                        case 'hard':
                            return 0.3 + Math.random() * 0.5; // 0.3-0.8 second delays
                        default:
                            return 2 + Math.random() * 2; // Very slow
                    }
                };
                
                // State machine
                switch(this.state) {
                    case 'approach':
                        if (distance > 2) { // Increased distance requirement
                            // Move more slowly and hesitantly
                            if (Math.random() < 0.7) { // Don't always move
                                if (this.fighter.x < this.opponent.x) {
                                    this.fighter.moveRight();
                                } else {
                                    this.fighter.moveLeft();
                                }
                            }
                            
                            // Jump much less frequently
                            if (Math.random() < this.aggression * 0.005) {
                                this.fighter.jump();
                            }
                            
                            // Add random pauses
                            if (Math.random() < 0.1) {
                                this.confusionTimer = 0.5 + Math.random() * 1;
                            }
                        } else {
                            this.state = Math.random() < effectiveAggression * 0.5 ? 'attack' : 'evaluate';
                            this.stateTimer = 0;
                            this.reactionTime = getActionDelay();
                        }
                        break;
                        
                    case 'evaluate':
                        this.fighter.stop();
                        
                        // Block more often but less effectively
                        if (Math.random() < (1 - this.aggression) * 0.3) {
                            this.fighter.blocking = true;
                            this.blockCounter = 0.3 + Math.random() * 0.5;
                        }
                        
                        if (this.stateTimer > 1 + Math.random() * 1.5) { // Longer evaluation
                            this.state = 'attack';
                            this.stateTimer = 0;
                            this.reactionTime = getActionDelay();
                        }
                        break;
                        
                    case 'attack':
                        this.fighter.stop();
                        
                        if (this.blockCounter > 0) {
                            this.blockCounter -= deltaTime;
                            if (this.blockCounter <= 0) {
                                this.fighter.blocking = false;
                            }
                        }
                        
                        if (this.attackCooldown <= 0) {
                            const shouldUseSpecial = this.shouldUseSpecial();
                            
                            // Miss attacks more often on easier difficulties
                            const hitChance = this.difficulty === 'easy' ? 0.4 : 
                                             this.difficulty === 'medium' ? 0.7 : 0.9;
                            
                            if (Math.random() < hitChance) {
                                if (shouldUseSpecial && this.fighter.specialCooldown <= 0) {
                                    this.fighter.attack('special', this.opponent);
                                    this.attackCooldown = 3 + Math.random() * 2; // Much longer cooldown
                                } else {
                                    // Choose attack based on aggression
                                    const attackChoice = Math.random();
                                    if (attackChoice < effectiveAggression * 0.4) {
                                        this.fighter.attack('kick', this.opponent);
                                        this.attackCooldown = 1.5 + Math.random() * 1.5; // Longer cooldowns
                                    } else {
                                        this.fighter.attack('punch', this.opponent);
                                        this.attackCooldown = 1 + Math.random() * 1; // Longer cooldowns
                                    }
                                }
                            } else {
                                // Missed attack - still has cooldown
                                this.attackCooldown = 0.5 + Math.random() * 0.5;
                            }
                            
                            this.state = effectiveAggression > 0.3 ? 'pursue' : 'retreat';
                            this.stateTimer = 0;
                            this.reactionTime = getActionDelay();
                        }
                        break;
                        
                    case 'pursue':
                        // Much less aggressive follow-up
                        if (Math.random() < 0.6) { // Don't always pursue
                            if (this.fighter.x < this.opponent.x) {
                                this.fighter.moveRight();
                            } else {
                                this.fighter.moveLeft();
                            }
                        }
                        
                        if (this.stateTimer > 1 + Math.random() * 1) { // Longer pursuit
                            this.state = 'attack';
                            this.stateTimer = 0;
                            this.reactionTime = getActionDelay();
                        }
                        break;
                        
                    case 'retreat':
                        // Defensive retreat
                        if (this.fighter.x < this.opponent.x) {
                            this.fighter.moveLeft();
                        } else {
                            this.fighter.moveRight();
                        }
                        
                        // Block while retreating more often
                        if (Math.random() < (1 - this.aggression) * 0.4) {
                            this.fighter.blocking = true;
                            this.blockCounter = 0.5 + Math.random() * 0.5;
                        }
                        
                        if (distance > 2.5 || this.stateTimer > 1.5 + Math.random() * 1) {
                            this.state = 'approach';
                            this.stateTimer = 0;
                            this.reactionTime = getActionDelay();
                        }
                        break;
                }
                
                // Pattern recognition - much less frequent on easy
                const counterChance = this.difficulty === 'easy' ? 0.02 : 
                                     this.difficulty === 'medium' ? 0.05 : 0.1;
                if (distance < 1.5 && Math.random() < counterChance) {
                    this.fighter.blocking = true;
                    setTimeout(() => { this.fighter.blocking = false; }, 300);
                }
            }

            shouldUseSpecial() {
                const healthPercent = this.fighter.health / this.fighter.maxHealth;
                const opponentHealthPercent = this.opponent.health / this.opponent.maxHealth;
                
                // Different strategies based on difficulty
                if (this.difficulty === 'hard') {
                    // Strategic use based on piece type
                    switch(this.fighter.piece.type) {
                        case PIECE_TYPES.PAWN:
                            return healthPercent < 0.5; // Heal when hurt
                        case PIECE_TYPES.KNIGHT:
                            return Math.random() < 0.3; // Use speed less frequently
                        case PIECE_TYPES.BISHOP:
                            return opponentHealthPercent > 0.7; // Shield early
                        case PIECE_TYPES.ROOK:
                            return healthPercent < 0.6; // Fortress when threatened
                        case PIECE_TYPES.QUEEN:
                            return this.opponent.frozen <= 0 && Math.random() < 0.4; // Freeze less often
                        case PIECE_TYPES.KING:
                            return healthPercent < 0.7; // Rally when damaged
                        default:
                            return Math.random() < 0.2;
                    }
                } else if (this.difficulty === 'medium') {
                    return healthPercent < 0.3 || Math.random() < 0.1;
                } else {
                    return healthPercent < 0.2 && Math.random() < 0.15; // Very rarely use special
                }
            }
        }

        function highlightLegalMoves(piece) {
            clearHighlights();
            legalMoves = piece.getLegalMoves();
            
            // Add selection highlight for the piece itself
            const selectionGeometry = new THREE.RingGeometry(0.5, 0.6, 32);
            const selectionMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD700,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const selectionHighlight = new THREE.Mesh(selectionGeometry, selectionMaterial);
            selectionHighlight.rotation.x = -Math.PI / 2;
            selectionHighlight.position.set(piece.x - 3.5, 0.02, piece.y - 3.5);
            scene.add(selectionHighlight);
            highlightMeshes.push(selectionHighlight);
            
            legalMoves.forEach(move => {
                const geometry = new THREE.PlaneGeometry(0.9, 0.9);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00FF00,
                    transparent: true,
                    opacity: 0.5
                });
                const highlight = new THREE.Mesh(geometry, material);
                highlight.rotation.x = -Math.PI / 2;
                highlight.position.set(move.x - 3.5, 0.01, move.y - 3.5);
                scene.add(highlight);
                highlightMeshes.push(highlight);
            });
        }

        function clearHighlights() {
            highlightMeshes.forEach(mesh => scene.remove(mesh));
            highlightMeshes = [];
        }

        function movePiece(piece, targetX, targetY) {
            if (fighting || gameOver) {
                console.log('Move blocked - fighting or game over:', { fighting, gameOver });
                return;
            }
            
            // Validate piece exists
            if (!piece || pieces.indexOf(piece) === -1) {
                console.error('Tried to move a piece that does not exist!');
                return;
            }
            
            // Validate it's the piece's turn
            if (piece.color !== currentTurn) {
                console.error('Tried to move piece when not its turn!', piece.color, 'vs', currentTurn);
                return;
            }
            
            // Validate target coordinates
            if (targetX < 0 || targetX >= 8 || targetY < 0 || targetY >= 8) {
                console.error('Invalid target coordinates:', targetX, targetY);
                return;
            }
            
            console.log('Moving piece:', piece.type, piece.color, 'from', piece.x, piece.y, 'to', targetX, targetY);
            
            // Get current legal moves to validate
            const currentLegalMoves = piece.getLegalMoves();
            const moveInfo = currentLegalMoves.find(m => m.x === targetX && m.y === targetY);
            
            if (!moveInfo) {
                console.error('Illegal move attempted!', piece.type, 'to', targetX, targetY);
                console.log('Legal moves:', currentLegalMoves);
                return;
            }
            
            const targetPiece = pieces.find(p => p.x === targetX && p.y === targetY);
            
            // Track if this is a pawn move or capture for 50-move rule
            const isPawnMove = piece.type === PIECE_TYPES.PAWN;
            const isCapture = targetPiece !== null;
            
            // Store original position for en passant
            const originalX = piece.x;
            const originalY = piece.y;
            
            // Handle special moves
            if (moveInfo && moveInfo.castle) {
                console.log('Executing castling move');
                // Castling
                piece.x = targetX;
                piece.y = targetY;
                piece.hasMoved = true;
                piece.mesh.position.set(targetX - 3.5, 0, targetY - 3.5);
                
                // Move the rook
                if (moveInfo.castle === 'kingside') {
                    const rook = pieces.find(p => p.x === 7 && p.y === targetY && p.type === PIECE_TYPES.ROOK);
                    if (rook) {
                        rook.x = 5;
                        rook.mesh.position.set(5 - 3.5, 0, targetY - 3.5);
                        rook.hasMoved = true;
                    }
                } else {
                    const rook = pieces.find(p => p.x === 0 && p.y === targetY && p.type === PIECE_TYPES.ROOK);
                    if (rook) {
                        rook.x = 3;
                        rook.mesh.position.set(3 - 3.5, 0, targetY - 3.5);
                        rook.hasMoved = true;
                    }
                }
                
                halfMoveClock++;
                
                // Validate board state
                if (!validateBoardState()) {
                    console.error('Board state validation failed after castling!');
                }
                
                endTurn();
            } else if (moveInfo && moveInfo.enPassant) {
                console.log('Executing en passant move');
                // En passant - this should also trigger a fight!
                const capturedPawn = pieces.find(p => p.x === targetX && p.y === originalY);
                if (capturedPawn) {
                    // Store the en passant info for after the fight
                    piece.enPassantCapture = {
                        targetX: targetX,
                        targetY: targetY,
                        capturedPawn: capturedPawn
                    };
                    // Start fight with the captured pawn
                    console.log('Starting en passant fight');
                    startFight(piece, capturedPawn);
                } else {
                    // Fallback if pawn not found
                    console.log('En passant pawn not found, doing normal move');
                    piece.x = targetX;
                    piece.y = targetY;
                    piece.hasMoved = true;
                    piece.mesh.position.set(targetX - 3.5, 0, targetY - 3.5);
                    halfMoveClock = 0;
                    endTurn();
                }
            } else if (targetPiece) {
                console.log('Executing capture move - starting fight');
                // Start fight!
                startFight(piece, targetPiece);
            } else {
                console.log('Executing normal move');
                // Normal move
                piece.x = targetX;
                piece.y = targetY;
                piece.hasMoved = true;
                piece.mesh.position.set(targetX - 3.5, 0, targetY - 3.5);
                
                // Update 50-move clock
                if (isPawnMove) {
                    halfMoveClock = 0;
                } else {
                    halfMoveClock++;
                }
                
                // Check for pawn promotion
                if (piece.type === PIECE_TYPES.PAWN) {
                    if ((piece.color === 'white' && targetY === 7) || 
                        (piece.color === 'black' && targetY === 0)) {
                        promotePawn(piece);
                    }
                }
                
                // Validate board state
                if (!validateBoardState()) {
                    console.error('Board state validation failed after normal move!');
                }
                
                endTurn();
            }
            
            // Reset en passant targets
            pieces.forEach(p => {
                if (p.type === PIECE_TYPES.PAWN) {
                    p.enPassantTarget = false;
                }
            });
            
            // Set en passant target for double pawn move
            if (piece.type === PIECE_TYPES.PAWN && Math.abs(targetY - originalY) === 2) {
                piece.enPassantTarget = true;
            }
        }

        function promotePawn(pawn) {
            // Auto-promote to queen for now
            const oldX = pawn.x;
            const oldY = pawn.y;
            const oldColor = pawn.color;
            
            pawn.type = PIECE_TYPES.QUEEN;
            pawn.maxHealth = PIECE_HEALTH.queen;
            pawn.health = pawn.maxHealth;
            
            // Update mesh
            scene.remove(pawn.mesh);
            pawn.mesh = pawn.createMesh();
            scene.add(pawn.mesh);
        }

        function validateBoardState() {
            // Check for duplicate pieces at same position
            const positionMap = new Map();
            for (const piece of pieces) {
                const key = `${piece.x},${piece.y}`;
                if (positionMap.has(key)) {
                    console.error('Duplicate pieces at position:', key, positionMap.get(key), piece);
                    return false;
                }
                positionMap.set(key, piece);
                
                // Check if piece position is valid
                if (piece.x < 0 || piece.x >= 8 || piece.y < 0 || piece.y >= 8) {
                    console.error('Piece outside board:', piece.type, piece.color, piece.x, piece.y);
                    return false;
                }
                
                // Check if piece mesh exists
                if (!piece.mesh) {
                    console.error('Piece missing mesh:', piece.type, piece.color);
                    return false;
                }
            }
            
            // Check for kings
            const whiteKing = pieces.find(p => p.type === PIECE_TYPES.KING && p.color === 'white');
            const blackKing = pieces.find(p => p.type === PIECE_TYPES.KING && p.color === 'black');
            
            if (!whiteKing && !blackKing) {
                console.error('Both kings missing!');
                return false;
            }
            
            return true;
        }

        function getSpecialAbilityDescription(pieceType) {
            switch(pieceType) {
                case PIECE_TYPES.PAWN:
                    return "Soldier's Resolve - Heals 20 HP instantly";
                case PIECE_TYPES.KNIGHT:
                    return "Gallant Charge - Gains speed boost for 3 seconds";
                case PIECE_TYPES.BISHOP:
                    return "Holy Ward - Reduces damage taken by 50% for 5 seconds";
                case PIECE_TYPES.ROOK:
                    return "Fortress Stance - Heavy damage reduction + auto-block for 4 seconds";
                case PIECE_TYPES.QUEEN:
                    return "Royal Command - Freezes opponent for 2 seconds";
                case PIECE_TYPES.KING:
                    return "Monarch's Rally - Heals 30 HP + damage boost for 5 seconds";
                default:
                    return "Unknown ability";
            }
        }

        function startFight(attackerPiece, defenderPiece) {
            if (fighting || gameOver) {
                console.log('Fight blocked:', { fighting, gameOver });
                return;
            }
            
            // Validate pieces exist
            if (!attackerPiece || !defenderPiece) {
                console.error('StartFight called with missing pieces!');
                return;
            }
            
            // Validate pieces are still in the game
            if (pieces.indexOf(attackerPiece) === -1 || pieces.indexOf(defenderPiece) === -1) {
                console.error('StartFight called with pieces not in game!');
                return;
            }
            
            console.log('Starting fight:', attackerPiece.type, attackerPiece.color, 'vs', defenderPiece.type, defenderPiece.color);
            console.log('Attacker at:', attackerPiece.x, attackerPiece.y);
            console.log('Defender at:', defenderPiece.x, defenderPiece.y);
            
            try {
                fighting = true;
                document.getElementById('fightUI').style.display = 'block';
                document.getElementById('ui').style.display = 'none';
            
            // Setup fight scene
            fightScene = new THREE.Scene();
            fightScene.background = new THREE.Color(0x000000);
            fightScene.fog = new THREE.Fog(0x000000, 10, 30);
            
            // Setup fight scene
            fightScene = new THREE.Scene();
            fightScene.background = new THREE.Color(0x000000);
            fightScene.fog = new THREE.Fog(0x000000, 10, 30);
            
            // Arena lighting - dramatic overhead lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            fightScene.add(ambientLight);
            
            // Main ring light
            const ringLight = new THREE.SpotLight(0xFFFFFF, 2);
            ringLight.position.set(0, 8, 0);
            ringLight.angle = Math.PI / 3;
            ringLight.penumbra = 0.2;
            ringLight.castShadow = true;
            ringLight.shadow.mapSize.width = 2048;
            ringLight.shadow.mapSize.height = 2048;
            fightScene.add(ringLight);
            
            // Corner lights
            const cornerColors = [0xFF0000, 0x0000FF, 0xFFFF00, 0x00FF00];
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const cornerLight = new THREE.PointLight(cornerColors[i], 0.5);
                cornerLight.position.set(Math.cos(angle) * 5, 3, Math.sin(angle) * 5);
                fightScene.add(cornerLight);
            }
            
            // Create octagonal ring platform
            const ringGeometry = new THREE.CylinderGeometry(4, 4, 0.5, 8);
            const ringMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a1a1a,
                emissive: 0x050505
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.y = -0.25;
            fightScene.add(ring);
            
            // Ring canvas with logo - changed to blue mat
            const canvasGeometry = new THREE.CylinderGeometry(3.8, 3.8, 0.1, 8);
            const canvasMaterial = new THREE.MeshPhongMaterial({
                color: 0x0b5394, // Blue mat color
                emissive: 0x1a1a1a,
                emissiveIntensity: 0.1
            });
            const canvas = new THREE.Mesh(canvasGeometry, canvasMaterial);
            canvas.position.y = 0.05;
            canvas.receiveShadow = true;
            fightScene.add(canvas);
            
            // Add ChessFighter logo in center
            const logoGeometry = new THREE.RingGeometry(0.5, 1.5, 8);
            const logoMaterial = new THREE.MeshBasicMaterial({
                color: 0x444444,
                side: THREE.DoubleSide
            });
            const logo = new THREE.Mesh(logoGeometry, logoMaterial);
            logo.rotation.x = -Math.PI / 2;
            logo.position.y = 0.06;
            fightScene.add(logo);
            
            // Create cage/ropes
            const ropeCount = 3;
            const posts = [];
            
            // Corner posts
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3);
                const postMaterial = new THREE.MeshPhongMaterial({
                    color: 0x333333,
                    emissive: cornerColors[Math.floor(i/2)] || 0x666666,
                    emissiveIntensity: 0.3
                });
                const post = new THREE.Mesh(postGeometry, postMaterial);
                post.position.set(Math.cos(angle) * 3.5, 1.5, Math.sin(angle) * 3.5);
                fightScene.add(post);
                posts.push(post);
                
                // Post pads
                const padGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.5);
                const padMaterial = new THREE.MeshPhongMaterial({
                    color: i % 2 === 0 ? 0xFF0000 : 0x0000FF
                });
                const pad = new THREE.Mesh(padGeometry, padMaterial);
                pad.position.copy(post.position);
                pad.position.y = 0.5;
                fightScene.add(pad);
            }
            
            // Create ropes between posts
            for (let r = 0; r < ropeCount; r++) {
                const ropeY = 0.5 + r * 0.7;
                for (let i = 0; i < 8; i++) {
                    const nextI = (i + 1) % 8;
                    const angle1 = (i / 8) * Math.PI * 2;
                    const angle2 = (nextI / 8) * Math.PI * 2;
                    
                    const ropeGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1.2);
                    const ropeMaterial = new THREE.MeshPhongMaterial({
                        color: r === 0 ? 0xFF0000 : r === 1 ? 0xFFFFFF : 0x0000FF,
                        emissive: 0x333333,
                        emissiveIntensity: 0.2
                    });
                    const rope = new THREE.Mesh(ropeGeometry, ropeMaterial);
                    
                    const midX = (Math.cos(angle1) + Math.cos(angle2)) * 1.75;
                    const midZ = (Math.sin(angle1) + Math.sin(angle2)) * 1.75;
                    rope.position.set(midX, ropeY, midZ);
                    rope.lookAt(Math.cos(angle2) * 3.5, ropeY, Math.sin(angle2) * 3.5);
                    rope.rotateX(Math.PI / 2);
                    
                    fightScene.add(rope);
                }
            }
            
            // Add audience (simple representation)
            const audienceGeometry = new THREE.TorusGeometry(8, 2, 8, 16);
            const audienceMaterial = new THREE.MeshBasicMaterial({
                color: 0x111111,
                side: THREE.DoubleSide
            });
            const audience = new THREE.Mesh(audienceGeometry, audienceMaterial);
            audience.position.y = 1;
            fightScene.add(audience);
            
            // Crowd particles for atmosphere
            const crowdCount = 200;
            const crowdGeometry = new THREE.BufferGeometry();
            const crowdPositions = new Float32Array(crowdCount * 3);
            const crowdColors = new Float32Array(crowdCount * 3);
            
            for (let i = 0; i < crowdCount * 3; i += 3) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 6 + Math.random() * 4;
                const height = 1 + Math.random() * 3;
                
                crowdPositions[i] = Math.cos(angle) * radius;
                crowdPositions[i + 1] = height;
                crowdPositions[i + 2] = Math.sin(angle) * radius;
                
                // Random crowd colors
                const brightness = 0.1 + Math.random() * 0.2;
                crowdColors[i] = brightness;
                crowdColors[i + 1] = brightness;
                crowdColors[i + 2] = brightness;
            }
            
            crowdGeometry.setAttribute('position', new THREE.BufferAttribute(crowdPositions, 3));
            crowdGeometry.setAttribute('color', new THREE.BufferAttribute(crowdColors, 3));
            
            const crowdMaterial = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.6
            });
            const crowd = new THREE.Points(crowdGeometry, crowdMaterial);
            fightScene.add(crowd);
            
            // Animate crowd
            let crowdAnimationId;
            const animateCrowd = () => {
                if (!fighting) return;
                try {
                    crowd.rotation.y += 0.001;
                    const positions = crowd.geometry.attributes.position.array;
                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] += Math.sin(Date.now() * 0.001 + i) * 0.002;
                    }
                    crowd.geometry.attributes.position.needsUpdate = true;
                    crowdAnimationId = requestAnimationFrame(animateCrowd);
                } catch (error) {
                    console.warn('Crowd animation error:', error);
                }
            };
            animateCrowd();
            
            // Store the animation ID for cleanup
            fightScene.userData = { crowdAnimationId };
            
            // Create fighters
            attacker = new Fighter(attackerPiece, true);
            defender = new Fighter(defenderPiece, false);
            attacker.isPawnMove = attackerPiece.type === PIECE_TYPES.PAWN; // Store for 50-move rule
            fightScene.add(attacker.mesh);
            fightScene.add(defender.mesh);
            
            // Determine which fighter the human player controls
            let humanFighter = null;
            let aiFighter = null;
            
            if (gameMode === 'twoPlayer') {
                // In two-player mode, no AI control needed
                humanFighter = attacker; // Player 1 (current turn) controls attacker
            } else {
                // In AI mode, human always controls their color (white), AI controls black
                if (attackerPiece.color === 'white') {
                    humanFighter = attacker;
                    aiFighter = defender;
                } else {
                    humanFighter = defender;
                    aiFighter = attacker;
                }
            }
            
            // Store references for input handling
            window.humanFighter = humanFighter;
            window.aiFighter = aiFighter;
            
            // Initialize AI for the AI fighter
            if (aiFighter) {
                aiFighter.ai = new FightingAI(aiFighter, humanFighter);
                console.log('AI will control:', aiFighter.piece.color, aiFighter.piece.type);
            }
            
            console.log('Human will control:', humanFighter.piece.color, humanFighter.piece.type);
            console.log('Fighter positions - Attacker:', attacker.piece.color, 'at', attacker.x, 'Defender:', defender.piece.color, 'at', defender.x);
            
            // Update UI
            document.getElementById('attackerName').textContent = 
                `${attackerPiece.color.toUpperCase()} ${attackerPiece.type.toUpperCase()}`;
            document.getElementById('defenderName').textContent = 
                `${defenderPiece.color.toUpperCase()} ${defenderPiece.type.toUpperCase()}`;
            
            // Highlight which fighter the human controls
            if (humanFighter === attacker) {
                document.getElementById('attackerName').style.color = '#00FF00';
                document.getElementById('attackerName').style.fontWeight = 'bold';
                document.getElementById('attackerName').textContent += ' (YOU)';
                document.getElementById('defenderName').style.color = '#FF0000';
                document.getElementById('defenderName').style.fontWeight = 'normal';
                if (aiFighter) {
                    document.getElementById('defenderName').textContent += ' (AI)';
                }
            } else {
                document.getElementById('defenderName').style.color = '#00FF00';
                document.getElementById('defenderName').style.fontWeight = 'bold';
                document.getElementById('defenderName').textContent += ' (YOU)';
                document.getElementById('attackerName').style.color = '#FF0000';
                document.getElementById('attackerName').style.fontWeight = 'normal';
                if (aiFighter) {
                    document.getElementById('attackerName').textContent += ' (AI)';
                }
            }
            
            document.getElementById('attackerHP').textContent = attacker.health;
            document.getElementById('attackerMaxHP').textContent = attacker.maxHealth;
            document.getElementById('defenderHP').textContent = defender.health;
            document.getElementById('defenderMaxHP').textContent = defender.maxHealth;
            
            // Update special ability descriptions
            document.getElementById('attackerAbilityTitle').textContent = 
                `${attackerPiece.color.toUpperCase()} ${attackerPiece.type.toUpperCase()} Special:`;
            document.getElementById('attackerAbilityDesc').textContent = 
                getSpecialAbilityDescription(attackerPiece.type);
            document.getElementById('defenderAbilityTitle').textContent = 
                `${defenderPiece.color.toUpperCase()} ${defenderPiece.type.toUpperCase()} Special:`;
            document.getElementById('defenderAbilityDesc').textContent = 
                getSpecialAbilityDescription(defenderPiece.type);
            
            // Play fight start sound
            playSound('special');
            
            // Start fight timer - longer on easier difficulties
            let fightTime;
            if (gameMode === 'twoPlayer') {
                fightTime = 40; // 40 seconds for two-player
            } else {
                switch(aiDifficulty) {
                    case 'easy':
                        fightTime = 45; // 45 seconds
                        break;
                    case 'medium':
                        fightTime = 35; // 35 seconds
                        break;
                    case 'hard':
                        fightTime = 30; // 30 seconds
                        break;
                    default:
                        fightTime = 45; // Default to easy
                }
            }
            
            let timeLeft = fightTime;
            document.getElementById('fightTimer').textContent = timeLeft;
            
            fightTimer = setInterval(() => {
                timeLeft--;
                document.getElementById('fightTimer').textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    endFight(false); // Defender wins on timeout
                }
            }, 1000);
            
            // Switch camera - lower angle for more dramatic view
            fightCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            fightCamera.position.set(0, 3, 7);
            fightCamera.lookAt(0, 0.5, 0);
            
            animate();
            
            console.log('Fight started successfully');
            
            } catch (error) {
                console.error('Error in startFight:', error);
                // Force cleanup in case of error
                fighting = false;
                document.getElementById('fightUI').style.display = 'none';
                document.getElementById('ui').style.display = 'block';
                
                // Reset UI colors
                document.getElementById('attackerName').style.color = '';
                document.getElementById('defenderName').style.color = '';
                document.getElementById('attackerName').style.fontWeight = '';
                document.getElementById('defenderName').style.fontWeight = '';
                document.getElementById('attackerName').style.fontWeight = '';
                document.getElementById('defenderName').style.fontWeight = '';
                if (fightTimer) {
                    clearInterval(fightTimer);
                    fightTimer = null;
                }
                // Force turn end to keep game going
                endTurn();
            }
        }

        function endFight(attackerWins) {
            if (!fighting) {
                console.log('EndFight called but not fighting');
                return;
            }
            
            if (!attacker || !defender) {
                console.error('EndFight called but attacker or defender is missing!');
                return;
            }
            
            console.log('Ending fight, attacker wins:', attackerWins);
            console.log('Attacker:', attacker.piece.type, attacker.piece.color, 'at', attacker.piece.x, attacker.piece.y);
            console.log('Defender:', defender.piece.type, defender.piece.color, 'at', defender.piece.x, defender.piece.y);
            
            try {
                if (fightTimer) {
                    clearInterval(fightTimer);
                    fightTimer = null;
                }
                fighting = false;
                document.getElementById('fightUI').style.display = 'none';
                document.getElementById('ui').style.display = 'block';
                
                // Clear fight scene properly
                if (fightScene) {
                    // Cancel crowd animation
                    if (fightScene.userData && fightScene.userData.crowdAnimationId) {
                        cancelAnimationFrame(fightScene.userData.crowdAnimationId);
                    }
                    
                    // Remove all objects from fight scene
                    while(fightScene.children.length > 0) {
                        fightScene.remove(fightScene.children[0]);
                    }
                    fightScene = null;
                }
                fightCamera = null;
                
                let kingKilled = false;
                let killedKingColor = null;
                
                if (attackerWins) {
                    console.log('Attacker won the fight');
                    // Check if this was an en passant capture
                    if (attacker.piece.enPassantCapture) {
                        const enPassantInfo = attacker.piece.enPassantCapture;
                        
                        console.log('Handling en passant capture');
                        
                        // Move attacker to en passant target square
                        attacker.piece.x = enPassantInfo.targetX;
                        attacker.piece.y = enPassantInfo.targetY;
                        attacker.piece.hasMoved = true;
                        attacker.piece.mesh.position.set(
                            enPassantInfo.targetX - 3.5,
                            0,
                            enPassantInfo.targetY - 3.5
                        );
                        
                        // Remove the captured pawn from its original position
                        const defenderIndex = pieces.indexOf(enPassantInfo.capturedPawn);
                        if (defenderIndex > -1) {
                            console.log('Removing captured pawn from en passant');
                            scene.remove(enPassantInfo.capturedPawn.mesh);
                            pieces.splice(defenderIndex, 1);
                            capturedPieces[attacker.piece.color].push(enPassantInfo.capturedPawn.type);
                            updateCapturedDisplay();
                        } else {
                            console.error('En passant captured pawn not found in pieces array!');
                        }
                        
                        // Clean up
                        delete attacker.piece.enPassantCapture;
                    } else {
                        // Normal capture - check if defender is a king
                        if (defender.piece.type === PIECE_TYPES.KING) {
                            kingKilled = true;
                            killedKingColor = defender.piece.color;
                            console.log('King killed in battle!', killedKingColor);
                        }
                        
                        // Store defender position before removing
                        const defX = defender.piece.x;
                        const defY = defender.piece.y;
                        
                        // Remove defender piece
                        const defenderIndex = pieces.indexOf(defender.piece);
                        if (defenderIndex > -1) {
                            console.log('Removing defender piece:', defender.piece.type, defender.piece.color);
                            scene.remove(defender.piece.mesh);
                            pieces.splice(defenderIndex, 1);
                            capturedPieces[attacker.piece.color].push(defender.piece.type);
                            updateCapturedDisplay();
                        } else {
                            console.error('Defender piece not found in pieces array!');
                        }
                        
                        // Move attacker to captured square
                        console.log('Moving attacker to defender position:', defX, defY);
                        attacker.piece.x = defX;
                        attacker.piece.y = defY;
                        attacker.piece.hasMoved = true;
                        attacker.piece.mesh.position.set(
                            defX - 3.5,
                            0,
                            defY - 3.5
                        );
                    }
                    
                    // Reset 50-move clock on capture
                    halfMoveClock = 0;
                    
                    // Check for pawn promotion
                    if (attacker.piece.type === PIECE_TYPES.PAWN) {
                        if ((attacker.piece.color === 'white' && attacker.piece.y === 7) || 
                            (attacker.piece.color === 'black' && attacker.piece.y === 0)) {
                            promotePawn(attacker.piece);
                        }
                    }
                } else {
                    console.log('Defender won the fight');
                    // Defender wins - check if attacker was a king
                    if (attacker.piece.type === PIECE_TYPES.KING) {
                        kingKilled = true;
                        killedKingColor = attacker.piece.color;
                        console.log('King killed in battle!', killedKingColor);
                    }
                    
                    // Remove attacker
                    const attackerIndex = pieces.indexOf(attacker.piece);
                    if (attackerIndex > -1) {
                        console.log('Removing attacker piece:', attacker.piece.type, attacker.piece.color);
                        scene.remove(attacker.piece.mesh);
                        pieces.splice(attackerIndex, 1);
                        capturedPieces[defender.piece.color].push(attacker.piece.type);
                        updateCapturedDisplay();
                    } else {
                        console.error('Attacker piece not found in pieces array!');
                    }
                    
                    // Clean up en passant info if it exists
                    if (attacker.piece && attacker.piece.enPassantCapture) {
                        delete attacker.piece.enPassantCapture;
                    }
                    
                    // Still counts as a move attempt
                    if (attacker.isPawnMove) {
                        halfMoveClock = 0;
                    } else {
                        halfMoveClock++;
                    }
                }
                
                // Clear fight references
                attacker = null;
                defender = null;
                window.humanFighter = null;
                window.aiFighter = null;
                
                console.log('Pieces remaining after fight:', pieces.length);
                
                // Validate board state
                if (!validateBoardState()) {
                    console.error('Board state validation failed after fight!');
                }
                
                // Check for game over due to king death
                if (kingKilled) {
                    gameOver = true;
                    const winner = killedKingColor === 'white' ? 'Black' : 'White';
                    console.log('Game over! Winner:', winner);
                    endGame(`${winner} wins by killing the ${killedKingColor} king!`);
                    playSound('checkmate');
                } else {
                    console.log('Fight ended, continuing game');
                    endTurn();
                }
                
            } catch (error) {
                console.error('Error in endFight:', error);
                // Force cleanup in case of error
                fighting = false;
                document.getElementById('fightUI').style.display = 'none';
                document.getElementById('ui').style.display = 'block';
                attacker = null;
                defender = null;
                endTurn();
            }
        }

        function updateCapturedDisplay() {
            const pieceSymbols = {
                pawn: '',
                knight: '',
                bishop: '',
                rook: '',
                queen: '',
                king: ''
            };
            
            document.getElementById('whiteCaptured').textContent = 
                capturedPieces.white.map(type => pieceSymbols[type]).join(' ');
            document.getElementById('blackCaptured').textContent = 
                capturedPieces.black.map(type => pieceSymbols[type]).join(' ');
        }

        function endTurn() {
            if (gameOver || fighting) {
                console.log('EndTurn blocked:', { gameOver, fighting });
                return;
            }
            
            clearHighlights();
            selectedPiece = null;
            
            const previousTurn = currentTurn;
            currentTurn = currentTurn === 'white' ? 'black' : 'white';
            document.getElementById('turnIndicator').textContent = 
                `${currentTurn.charAt(0).toUpperCase() + currentTurn.slice(1)}'s Turn`;
            
            console.log('Turn ended, was', previousTurn, 'now', currentTurn);
            
            // Add to move history
            const boardState = pieces.map(p => ({ type: p.type, color: p.color, x: p.x, y: p.y }))
                .sort((a, b) => a.x - b.x || a.y - b.y);
            moveHistory.push({ board: boardState });
            
            // Update position history for threefold repetition
            const positionString = JSON.stringify(boardState);
            positionHistory.push(positionString);
            
            // Check for threefold repetition
            const positionCount = positionHistory.filter(pos => pos === positionString).length;
            if (positionCount >= 3) {
                gameOver = true;
                endGame('Threefold repetition! Draw!');
                playSound('stalemate');
                return;
            }
            
            // Check 50-move rule
            if (halfMoveClock >= 100) { // 50 moves = 100 half-moves
                gameOver = true;
                endGame('50-move rule! Draw!');
                playSound('stalemate');
                return;
            }
            
            // Check for game end conditions
            updateCheckStatus();
            
            if (checkForCheckmate(currentTurn)) {
                gameOver = true;
                endGame(`${currentTurn === 'white' ? 'Black' : 'White'} wins by checkmate!`);
                playSound('checkmate');
                return;
            } else if (checkForStalemate(currentTurn)) {
                gameOver = true;
                endGame('Stalemate! Draw!');
                playSound('stalemate');
                return;
            }
            
            // Make AI move if it's AI's turn
            if (gameMode !== 'twoPlayer' && currentTurn === 'black' && !fighting && !gameOver) {
                console.log('Calling makeAIMove... (current turn:', currentTurn, ')');
                // Add a small delay to prevent race conditions
                setTimeout(() => {
                    if (currentTurn === 'black' && !fighting && !gameOver) {
                        makeAIMove();
                    } else {
                        console.log('AI move skipped - conditions changed');
                    }
                }, 100);
            }
        }

        function endGame(message) {
            document.getElementById('victoryMessage').textContent = message.includes('Checkmate') ? 'Checkmate!' : 'Stalemate!';
            document.getElementById('winnerMessage').textContent = message;
            
            // Dramatic effects for checkmate
            if (message.includes('checkmate')) {
                const king = pieces.find(p => p.type === PIECE_TYPES.KING && p.color === currentTurn);
                if (king) {
                    // Zoom camera to king
                    cameraAnimating = true;
                    const targetZoom = 3;
                    
                    const zoomAnimation = () => {
                        const currentZoom = Math.abs(camera.top - camera.bottom);
                        const newZoom = currentZoom + (targetZoom - currentZoom) * 0.1;
                        
                        const aspect = window.innerWidth / window.innerHeight;
                        camera.left = -newZoom * aspect / 2;
                        camera.right = newZoom * aspect / 2;
                        camera.top = newZoom / 2;
                        camera.bottom = -newZoom / 2;
                        camera.updateProjectionMatrix();
                        
                        // Move camera to king position
                        const targetX = king.x - 3.5;
                        const targetZ = king.y - 3.5;
                        camera.position.x += (targetX - camera.position.x) * 0.1;
                        camera.position.z += (targetZ - camera.position.z) * 0.1;
                        
                        if (Math.abs(currentZoom - targetZoom) > 0.1) {
                            requestAnimationFrame(zoomAnimation);
                        } else {
                            // King glow and shatter
                            king.mesh.children.forEach(child => {
                                if (child.material) {
                                    child.material.emissive = new THREE.Color(0xFF0000);
                                    child.material.emissiveIntensity = 1;
                                }
                            });
                            
                            setTimeout(() => {
                                // Create shatter effect
                                for (let i = 0; i < 30; i++) {
                                    const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                                    const material = new THREE.MeshPhongMaterial({
                                        color: king.color === 'white' ? 0xFFFFFF : 0x333333,
                                        emissive: 0xFF0000,
                                        emissiveIntensity: 0.5
                                    });
                                    const fragment = new THREE.Mesh(geometry, material);
                                    fragment.position.copy(king.mesh.position);
                                    fragment.position.x += (Math.random() - 0.5) * 0.5;
                                    fragment.position.y += Math.random() * 0.5;
                                    fragment.position.z += (Math.random() - 0.5) * 0.5;
                                    
                                    const vx = (Math.random() - 0.5) * 0.1;
                                    const vy = Math.random() * 0.1 + 0.05;
                                    const vz = (Math.random() - 0.5) * 0.1;
                                    
                                    scene.add(fragment);
                                    
                                    // Animate fragment
                                    const animateFragment = () => {
                                        fragment.position.x += vx;
                                        fragment.position.y += vy;
                                        fragment.position.z += vz;
                                        fragment.rotation.x += 0.1;
                                        fragment.rotation.y += 0.1;
                                        fragment.scale.multiplyScalar(0.95);
                                        
                                        if (fragment.scale.x > 0.01) {
                                            requestAnimationFrame(animateFragment);
                                        } else {
                                            scene.remove(fragment);
                                        }
                                    };
                                    animateFragment();
                                }
                                
                                // Remove king
                                scene.remove(king.mesh);
                                
                                // Fade out losing pieces
                                const losingPieces = pieces.filter(p => p.color === currentTurn);
                                losingPieces.forEach((piece, index) => {
                                    if (piece !== king) {
                                        setTimeout(() => {
                                            const fadeOut = () => {
                                                piece.mesh.children.forEach(child => {
                                                    if (child.material) {
                                                        child.material.opacity *= 0.95;
                                                        child.material.transparent = true;
                                                    }
                                                });
                                                
                                                if (piece.mesh.children[0] && piece.mesh.children[0].material.opacity > 0.01) {
                                                    requestAnimationFrame(fadeOut);
                                                } else {
                                                    scene.remove(piece.mesh);
                                                }
                                            };
                                            fadeOut();
                                        }, index * 100);
                                    }
                                });
                                
                                // Show victory screen after animations
                                setTimeout(() => {
                                    document.getElementById('victoryScreen').style.display = 'flex';
                                }, 2000);
                            }, 500);
                        }
                    };
                    zoomAnimation();
                } else {
                    document.getElementById('victoryScreen').style.display = 'flex';
                }
            } else {
                // Stalemate - dim the board
                board.forEach(square => {
                    const dimAnimation = () => {
                        const currentColor = square.material.color;
                        const r = currentColor.r * 0.98;
                        const g = currentColor.g * 0.98;
                        const b = currentColor.b * 0.98;
                        square.material.color.setRGB(r, g, b);
                        
                        if (r > 0.3) {
                            requestAnimationFrame(dimAnimation);
                        }
                    };
                    dimAnimation();
                });
                
                // Dim pieces
                pieces.forEach(piece => {
                    piece.mesh.children.forEach(child => {
                        if (child.material) {
                            child.material.emissiveIntensity = 0;
                        }
                    });
                });
                
                setTimeout(() => {
                    document.getElementById('victoryScreen').style.display = 'flex';
                }, 1000);
            }
        }

        function initChessBoard() {
            // Create board squares
            board = []; // Clear existing board
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const geometry = new THREE.PlaneGeometry(1, 1);
                    const material = new THREE.MeshPhongMaterial({
                        color: (i + j) % 2 === 0 ? 0xEEEED2 : 0x769656
                    });
                    const square = new THREE.Mesh(geometry, material);
                    square.rotation.x = -Math.PI / 2;
                    square.position.set(i - 3.5, -0.01, j - 3.5);
                    square.receiveShadow = true;
                    scene.add(square);
                    board.push(square);
                }
            }
            
            // Initialize pieces
            setupPieces();
        }

        function setupPieces() {
            // Clear existing pieces
            pieces.forEach(p => scene.remove(p.mesh));
            pieces = [];
            capturedPieces = { white: [], black: [] };
            updateCapturedDisplay();
            
            // Pawns
            for (let i = 0; i < 8; i++) {
                const whitePawn = new ChessPiece(PIECE_TYPES.PAWN, 'white', i, 1);
                const blackPawn = new ChessPiece(PIECE_TYPES.PAWN, 'black', i, 6);
                pieces.push(whitePawn);
                pieces.push(blackPawn);
            }
            
            // Other pieces
            const backRow = [
                PIECE_TYPES.ROOK, PIECE_TYPES.KNIGHT, PIECE_TYPES.BISHOP, PIECE_TYPES.QUEEN,
                PIECE_TYPES.KING, PIECE_TYPES.BISHOP, PIECE_TYPES.KNIGHT, PIECE_TYPES.ROOK
            ];
            
            backRow.forEach((type, i) => {
                const whitePiece = new ChessPiece(type, 'white', i, 0);
                const blackPiece = new ChessPiece(type, 'black', i, 7);
                pieces.push(whitePiece);
                pieces.push(blackPiece);
            });
            
            // Add all pieces to scene
            pieces.forEach(piece => scene.add(piece.mesh));
        }

        function handleClick(event) {
            if (fighting || gameOver || cameraAnimating) {
                console.log('Click blocked:', { fighting, gameOver, cameraAnimating });
                return;
            }
            
            event.preventDefault();
            
            // Get mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Set up raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Get all objects that can be intersected
            const intersectableObjects = [];
            
            // Add all piece meshes and their children to intersectable objects
            pieces.forEach(piece => {
                if (piece.mesh) {
                    intersectableObjects.push(piece.mesh);
                    // Add all children of the piece mesh
                    piece.mesh.traverse(child => {
                        if (child.isMesh) {
                            intersectableObjects.push(child);
                        }
                    });
                }
            });
            
            // Add board squares
            intersectableObjects.push(...board);
            
            // Perform raycasting
            const intersects = raycaster.intersectObjects(intersectableObjects, false);
            
            if (intersects.length > 0) {
                let clickedPiece = null;
                let clickedSquare = null;
                
                // Find the first piece or square that was clicked
                for (let i = 0; i < intersects.length; i++) {
                    const intersect = intersects[i];
                    
                    // Check if this is a piece (check object and its parents)
                    let obj = intersect.object;
                    while (obj) {
                        if (obj.userData && obj.userData.piece) {
                            clickedPiece = obj.userData.piece;
                            break;
                        }
                        obj = obj.parent;
                    }
                    
                    // If we found a piece, use it
                    if (clickedPiece) break;
                    
                    // Check if this is a board square
                    if (board.includes(intersect.object)) {
                        clickedSquare = intersect;
                        break;
                    }
                }
                
                if (clickedPiece) {
                    // Handle piece click
                    if (clickedPiece.color === currentTurn) {
                        // Select this piece
                        selectedPiece = clickedPiece;
                        highlightLegalMoves(clickedPiece);
                        console.log('Selected piece:', clickedPiece.type, clickedPiece.color);
                    } else if (selectedPiece) {
                        // Try to capture opponent piece
                        const isLegalCapture = legalMoves.some(move => 
                            move.x === clickedPiece.x && move.y === clickedPiece.y
                        );
                        
                        if (isLegalCapture) {
                            console.log('Capturing piece:', clickedPiece.type, clickedPiece.color);
                            movePiece(selectedPiece, clickedPiece.x, clickedPiece.y);
                        } else {
                            // Invalid move, deselect
                            clearHighlights();
                            selectedPiece = null;
                        }
                    }
                } else if (clickedSquare && selectedPiece) {
                    // Handle square click
                    const worldPos = clickedSquare.point;
                    const boardX = Math.round(worldPos.x + 3.5);
                    const boardY = Math.round(worldPos.z + 3.5);
                    
                    // Clamp to board bounds
                    const clampedX = Math.max(0, Math.min(7, boardX));
                    const clampedY = Math.max(0, Math.min(7, boardY));
                    
                    const isLegalMove = legalMoves.some(move => 
                        move.x === clampedX && move.y === clampedY
                    );
                    
                    if (isLegalMove) {
                        console.log('Moving to square:', clampedX, clampedY);
                        movePiece(selectedPiece, clampedX, clampedY);
                    } else {
                        // Invalid move, deselect
                        clearHighlights();
                        selectedPiece = null;
                    }
                } else {
                    // Clicked on empty space, deselect
                    clearHighlights();
                    selectedPiece = null;
                }
            } else {
                // No intersection, deselect
                clearHighlights();
                selectedPiece = null;
            }
        }

        function handleKeyDown(event) {
            keys[event.key.toLowerCase()] = true;
            
            if (!fighting || !window.humanFighter) return;
            
            switch(event.key.toLowerCase()) {
                case 'w':
                    window.humanFighter.jump();
                    break;
                case 'j':
                    window.humanFighter.attack('punch', window.humanFighter === attacker ? defender : attacker);
                    break;
                case 'k':
                    window.humanFighter.attack('kick', window.humanFighter === attacker ? defender : attacker);
                    break;
                case ' ':
                    event.preventDefault();
                    window.humanFighter.attack('special', window.humanFighter === attacker ? defender : attacker);
                    break;
                case 'l':
                    window.humanFighter.blocking = true;
                    break;
            }
        }

        function handleKeyUp(event) {
            keys[event.key.toLowerCase()] = false;
            
            if (!fighting || !window.humanFighter) return;
            
            if (event.key.toLowerCase() === 'l') {
                window.humanFighter.blocking = false;
            }
        }

        function updateFight() {
            if (!fighting) return;
            
            try {
                // Handle continuous movement for human player
                if (window.humanFighter) {
                    if (keys['a']) {
                        window.humanFighter.moveLeft();
                    } else if (keys['d']) {
                        window.humanFighter.moveRight();
                    } else {
                        window.humanFighter.stop();
                    }
                }
                
                // Update fighters
                attacker.update(0.016);
                defender.update(0.016);
                
                // Update AI if present
                if (window.aiFighter && window.aiFighter.ai) {
                    window.aiFighter.ai.update(0.016);
                }
                
                // Update health bars
                document.getElementById('attackerHealth').style.width = 
                    `${(attacker.health / attacker.maxHealth) * 100}%`;
                document.getElementById('defenderHealth').style.width = 
                    `${(defender.health / defender.maxHealth) * 100}%`;
                
                // Update special cooldown indicators
                document.getElementById('attackerSpecial').textContent = 
                    attacker.specialCooldown <= 0 ? 'Special Ready!' : `Cooldown: ${Math.ceil(attacker.specialCooldown)}s`;
                document.getElementById('attackerSpecial').style.color = 
                    attacker.specialCooldown <= 0 ? '#00FF00' : '#FF0000';
                document.getElementById('defenderSpecial').textContent = 
                    defender.specialCooldown <= 0 ? 'Special Ready!' : `Cooldown: ${Math.ceil(defender.specialCooldown)}s`;
                document.getElementById('defenderSpecial').style.color = 
                    defender.specialCooldown <= 0 ? '#00FF00' : '#FF0000';
                
                // Check win conditions
                if (attacker.health <= 0) {
                    endFight(false);
                } else if (defender.health <= 0) {
                    endFight(true);
                }
            } catch (error) {
                console.error('Error in updateFight:', error);
                // End fight safely on error
                endFight(false);
            }
        }

        function animate() {
            try {
                requestAnimationFrame(animate);
                
                if (fighting && fightScene && fightCamera && fightCamera.isCamera) {
                    updateFight();
                    renderer.render(fightScene, fightCamera);
                } else if (!fighting && scene && camera && camera.isCamera) {
                    renderer.render(scene, camera);
                }
            } catch (error) {
                console.error('Animation error:', error);
                // Try to recover gracefully
                requestAnimationFrame(animate);
            }
        }

        function init() {
            // Setup main scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x312E2B);
            
            // Setup camera - orthographic for perfect alignment
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 10;
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2,
                frustumSize * aspect / 2,
                frustumSize / 2,
                frustumSize / -2,
                0.1,
                1000
            );
            camera.position.set(0, 20, 0);
            camera.lookAt(0, 0, 0);
            
            // Setup renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Setup raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Initialize board and pieces
            initChessBoard();
            
            // Event listeners
            window.addEventListener('click', handleClick);
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            window.addEventListener('resize', () => {
                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = 10;
                camera.left = frustumSize * aspect / -2;
                camera.right = frustumSize * aspect / 2;
                camera.top = frustumSize / 2;
                camera.bottom = frustumSize / -2;
                camera.updateProjectionMatrix();
                
                if (fightCamera) {
                    fightCamera.aspect = window.innerWidth / window.innerHeight;
                    fightCamera.updateProjectionMatrix();
                }
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            animate();
        }

        function startTwoPlayer() {
            console.log('Starting two player game');
            gameMode = 'twoPlayer';
            document.getElementById('gameMode').textContent = 'Two Player';
            document.getElementById('startScreen').style.display = 'none';
            initAudio();
            init();
        }

        function startAI(difficulty) {
            console.log('Starting AI game with difficulty:', difficulty);
            gameMode = 'ai';
            aiDifficulty = difficulty;
            document.getElementById('gameMode').textContent = `vs AI (${difficulty})`;
            document.getElementById('startScreen').style.display = 'none';
            initAudio();
            init();
        }

        function rematch() {
            console.log('Starting rematch...');
            
            // Clear any existing timers
            if (fightTimer) {
                clearInterval(fightTimer);
                fightTimer = null;
            }
            
            // Reset all game state
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('fightUI').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            
            gameOver = false;
            fighting = false;
            currentTurn = 'white';
            isInCheck = false;
            checkingPieces = [];
            moveHistory = [];
            positionHistory = [];
            halfMoveClock = 0;
            cameraAnimating = false;
            selectedPiece = null;
            legalMoves = [];
            attacker = null;
            defender = null;
            window.humanFighter = null;
            window.aiFighter = null;
            
            // Clear highlights
            clearHighlights();
            
            // Reset camera position
            camera.position.set(0, 20, 0);
            camera.lookAt(0, 0, 0);
            
            // Reset camera projection
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = 10;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            
            // Reset board colors
            board.forEach((square, index) => {
                const i = Math.floor(index / 8);
                const j = index % 8;
                square.material.color.setHex((i + j) % 2 === 0 ? 0xEEEED2 : 0x769656);
            });
            
            document.getElementById('turnIndicator').textContent = "White's Turn";
            document.getElementById('ui').classList.remove('check-warning');
            setupPieces();
            
            console.log('Rematch setup complete');
        }

        function backToMenu() {
            location.reload();
        }
    </script>
</body>
</html>